<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>–ü–ª–∏—Ç–∫–∏</title>

  <script src="/sdk.js"></script>
  <style>
    :root{
      --cell-size: 40px;
      --cols: 6;
      --rows: 12;
      --gap: 6px;
      --bg:#071026;
      --panel:#0f1720;
      --muted:#9aa4b2;
      --scale: 1;
    }
    *{box-sizing:border-box;font-family:Inter, system-ui, Arial, sans-serif;-webkit-tap-highlight-color:transparent}
    html,body{height:100%;overflow: hidden; margin:0;background-image:url('background.jpg');background-size:cover;background-position:center;color:#e6eef6;overflow-x:hidden;touch-action:manipulation}

    /* layout */
    .app{display:flex;gap:16px;align-items:flex-start;justify-content: center; max-width:1100px;margin:12px auto; height: 100vh; transform: scale(var(--scale)); transform-origin: top center;}
    .board-wrap{background:linear-gradient(180deg,rgba(9,16,37,0.9),rgba(7,16,32,0.9));padding:12px;border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,0.6);position:relative}

    /* board grid (visual guide) */
    .board{position:relative;display:grid;grid-template-columns:repeat(var(--cols),var(--cell-size));grid-template-rows:repeat(var(--rows),var(--cell-size));gap:var(--gap);background:rgba(6,18,37,0.9);padding:12px;border-radius:10px;min-height:calc(var(--rows) * var(--cell-size) + (var(--rows)-1)*var(--gap));overflow:hidden}

    /* static cell background to keep grid look */
    .cell-bg{width:var(--cell-size);height:var(--cell-size);border-radius:8px;background:rgba(255,255,255,0.02);box-shadow:inset 0 -3px rgba(0,0,0,0.2)}

    /* floating tile elements for animation */
    .tile-el{position:absolute;width:var(--cell-size);height:var(--cell-size);display:flex;align-items:center;justify-content:center;border-radius:8px;font-weight:800;transition:transform 220ms cubic-bezier(.2,.9,.2,1), top 220ms cubic-bezier(.2,.9,.2,1), left 220ms cubic-bezier(.2,.9,.2,1);box-shadow:0 6px 18px rgba(2,6,23,0.6);pointer-events:none}
    .tile-el .label{transform:translateY(1px)}

    /* merge animation */
    .merge-anim{animation:mergePop 320ms ease forwards}
    @keyframes mergePop{0%{transform:scale(1)}40%{transform:scale(1.6)}100%{transform:scale(1)}}

    /* particle (star) */
    .particle{position:absolute;width:10px;height:10px;border-radius:50%;background:gold;box-shadow:0 0 8px gold, 0 0 20px rgba(255,200,50,0.6);pointer-events:none;opacity:0}
    @keyframes starFly{
      0%{opacity:1;transform:translate(0,0) scale(1)}
      60%{opacity:1}
      100%{opacity:0;transform:translate(var(--dx),var(--dy)) scale(0.6)}
    }

    /* praise text */
    .praise{position:absolute;font-weight:800;color:#fff;text-shadow:0 4px 16px rgba(0,0,0,0.6);pointer-events:none;opacity:0;transform:translateY(0);transition:transform 480ms cubic-bezier(.2,.9,.2,1),opacity 480ms}
    .praise.show{opacity:1;transform:translateY(-40px)}

    /* combo text */
    .combo{position:absolute;font-weight:900;color:#ffd86b;text-shadow:0 6px 18px rgba(0,0,0,0.6);pointer-events:none;opacity:0;transform:translateY(0);transition:transform 420ms cubic-bezier(.2,.9,.2,1),opacity 420ms;font-size:20px}
    .combo.show{opacity:1;transform:translateY(-36px) scale(1.05)}

    /* new record notification */
    .new-record{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);font-weight:900;color:#ffd86b;font-size:28px;text-shadow:0 6px 18px rgba(0,0,0,0.6);pointer-events:none;opacity:0;z-index:50;transition:transform 480ms cubic-bezier(.2,.9,.2,1),opacity 480ms}
    .new-record.show{opacity:1;transform:translate(-50%, -50%) scale(1.1)}

    /* tile colors (use data-val attribute) */
    .tile-el[data-val="2"]{background:linear-gradient(180deg,#f1efe9,#efe8d6);color:#2b2b2b}
    .tile-el[data-val="4"]{background:linear-gradient(180deg,#f3e7d7,#f0d8b7);color:#2b2b2b}
    .tile-el[data-val="8"]{background:linear-gradient(180deg,#f7cf95,#f0b46b);color:#111}
    .tile-el[data-val="16"]{background:linear-gradient(180deg,#f09e5b,#e67a3b);color:#fff}
    .tile-el[data-val="32"]{background:linear-gradient(180deg,#e86e4b,#c94c2f);color:#fff}
    .tile-el[data-val="64"]{background:linear-gradient(180deg,#d44c8a,#b7306f);color:#fff}
    .tile-el[data-val="128"]{background:linear-gradient(180deg,#6db7f7,#3b8fe8);color:#fff}
    .tile-el[data-val="256"]{background:linear-gradient(180deg,#74d7b2,#2db386);color:#042018}
    .tile-el[data-val="512"]{background:linear-gradient(180deg,#a293ff,#7a5dff);color:#fff}
    .tile-el[data-val="1024"]{background:linear-gradient(180deg,#ffd86b,#ffb84f);color:#111}
    .tile-el[data-val="2048"]{background:linear-gradient(180deg,#ffe0a9,#ffd676);color:#111}

    /* side panel */
    .side{display:flex;flex-direction:column;gap:12px;width:260px}
    .panel{background:var(--panel);padding:12px;border-radius:8px;box-shadow:inset 0 -4px rgba(0,0,0,.25)}
    .title{font-size:18px;font-weight:700;margin-bottom:6px}
    .stat{font-size:13px;color:var(--muted)}
    button{padding:10px;border-radius:8px;border:0;background:#0f1726;color:#dfe9f8;cursor:pointer}
    button.secondary{background:#121827;color:var(--muted)}
    .next-piece{display:grid;grid-template-columns:repeat(4,40px);grid-auto-rows:40px;gap:6px;justify-content:center}
    .footer{font-size:13px;color:var(--muted);margin-top:8px}
    .controls-list{font-size:13px;color:var(--muted);display:block;line-height:1.6}
    .hint{font-size:13px;color:#bcd0ff}
    .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:100}
    .overlay.show{display:flex}
    .modal{background:#0c1320;padding:24px;border-radius:12px;box-shadow:0 10px 40px rgba(0,0,0,0.6);max-width:90vw;max-height:90vh;overflow:auto}
    .small{font-size:12px;color:var(--muted)}
    
    /* Sound toggle button */
    .sound-toggle {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: rgba(15, 23, 38, 0.8);
      border: none;
      color: #dfe9f8;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      z-index: 10;
      transition: background 0.2s;
    }
    .sound-toggle:hover {
      background: rgba(15, 23, 38, 1);
    }
    .sound-toggle.muted {
      opacity: 0.5;
    }
    
    /* Pause button */
    .pause-toggle {
      position: absolute;
      top: 12px;
      right: 54px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: rgba(15, 23, 38, 0.8);
      border: none;
      color: #dfe9f8;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      z-index: 10;
      transition: background 0.2s;
    }
    .pause-toggle:hover {
      background: rgba(15, 23, 38, 1);
    }
    
    /* Start screen */
    .start-screen {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(5, 6, 10, 0.9);
      z-index: 200;
    }
    .start-modal {
      background: #0c1320;
      padding: 32px;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      max-width: 400px;
      text-align: center;
    }
    .start-title {
      font-size: 32px;
      font-weight: 900;
      margin-bottom: 20px;
      background: linear-gradient(180deg, #ffd86b, #ffb84f);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .start-description {
      font-size: 16px;
      color: #e6eef6;
      margin-bottom: 24px;
      line-height: 1.5;
    }
    .start-button {
      opacity: 0;
      padding: 12px 24px;
      font-size: 18px;
      font-weight: 700;
      background: linear-gradient(180deg, #3b8fe8, #2a6ac4);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .start-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(59, 143, 232, 0.4);
    }
    
    /* Pause menu */
    .pause-menu {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(5, 6, 10, 0.9);
      z-index: 150;
    }
    .pause-menu.show {
      display: flex;
    }
    .pause-modal {
      background: #0c1320;
      padding: 32px;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      max-width: 400px;
      text-align: center;
    }
    .pause-title {
      font-size: 28px;
      font-weight: 900;
      margin-bottom: 20px;
      color: #e6eef6;
    }
    .pause-buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .pause-button {
      padding: 12px 24px;
      font-size: 16px;
      font-weight: 700;
      background: #0f1726;
      color: #dfe9f8;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s, background 0.2s;
    }
    .pause-button:hover {
      transform: translateY(-2px);
      background: #1a2332;
    }
    .pause-button.primary {
      background: linear-gradient(180deg, #3b8fe8, #2a6ac4);
      color: white;
    }
    .pause-button.primary:hover {
      background: linear-gradient(180deg, #4a9cf8, #3979d4);
    }
    
    /* Leaderboard styles */
    .leaderboard {
      background: #0c1320;
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }
    .leaderboard-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 16px;
      color: #e6eef6;
      text-align: center;
    }
    .leaderboard-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .leaderboard-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 12px;
      background: rgba(15, 23, 38, 0.5);
      border-radius: 8px;
    }
    .leaderboard-item.current-player {
      background: rgba(59, 143, 232, 0.3);
      border: 1px solid rgba(59, 143, 232, 0.5);
    }
    .leaderboard-rank {
      font-weight: 700;
      color: #ffd86b;
      width: 30px;
    }
    .leaderboard-name {
      flex-grow: 1;
      margin: 0 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .leaderboard-score {
      font-weight: 700;
      color: #e6eef6;
    }
    .leaderboard-close {
      margin-top: 16px;
      width: 100%;
    }
    .leaderboard-loading {
      text-align: center;
      padding: 20px;
      color: var(--muted);
    }
    .leaderboard-empty {
      text-align: center;
      padding: 20px;
      color: var(--muted);
    }
    .leaderboard-separator {
      text-align: center;
      padding: 10px;
      color: var(--muted);
      font-size: 14px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      margin-top: 10px;
    }
    
    /* Responsive adjustments */
    @media (max-width: 620px), (max-height: 615px) {
      .app {
        margin: 0;
        gap: 8px;
      }
      .side {
        width: 200px;
      }
      .panel {
        padding: 8px;
      }
      .title {
        font-size: 16px;
      }
      .stat {
        font-size: 12px;
      }
      button {
        padding: 8px;
        font-size: 14px;
      }
      .next-piece {
        grid-template-columns: repeat(4, 30px);
        grid-auto-rows: 30px;
        gap: 4px;
      }
    }
  </style>
</head>
<body>
  <!-- Start Screen -->
  <div class="start-screen" id="startScreen">
    <div class="start-modal">
      <div class="start-description" data-i18n="game.description">
        –°–æ–µ–¥–∏–Ω—è–π—Ç–µ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –ø–ª–∏—Ç–∫–∏, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞–≤–∞—Ç—å –±–æ–ª—å—à–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è. 
        –£–ø—Ä–∞–≤–ª—è–π—Ç–µ —Ñ–∏–≥—É—Ä–∞–º–∏ –∏ —Å–æ–∑–¥–∞–≤–∞–π—Ç–µ –∫–æ–º–±–æ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –æ—á–∫–æ–≤!
      </div>
      <button class="start-button" id="startButton" data-i18n="game.start">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
    </div>
  </div>

  <!-- Pause Menu -->
  <div class="pause-menu" id="pauseMenu">
    <div class="pause-modal">
      <div class="pause-title" data-i18n="pause.title">–ü–ê–£–ó–ê</div>
      <div class="pause-buttons">
        <button class="pause-button primary" id="resumeButton" data-i18n="pause.resume">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
        <button class="pause-button" id="restartButton" data-i18n="pause.newGame">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
        <button class="pause-button" id="soundButton" data-i18n="pause.sound">–ó–≤—É–∫: –í–∫–ª</button>
        <button class="pause-button" id="leaderboardButton" data-i18n="pause.leaderboard">–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤</button>
      </div>
    </div>
  </div>

  <!-- Leaderboard Modal -->
  <div class="overlay" id="leaderboardOverlay">
    <div class="leaderboard">
      <div class="leaderboard-title" data-i18n="leaderboard.title">–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤</div>
      <div id="leaderboardContent" class="leaderboard-list">
        <div class="leaderboard-loading" data-i18n="leaderboard.loading">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
      </div>
      <button class="pause-button leaderboard-close" id="leaderboardClose" data-i18n="leaderboard.close">–ó–∞–∫—Ä—ã—Ç—å</button>
    </div>
  </div>

  <div class="app">
    <div class="side">
      <div class="panel">
        <div class="stat"><span data-i18n="ui.score">–°—á—ë—Ç</span>: <span id="score">0</span></div>
        <div class="stat"><span data-i18n="ui.best">–†–µ–∫–æ—Ä–¥</span>: <span id="best">0</span></div>
        <div style="height:8px"></div>
        <button id="restart" data-i18n="ui.newGame">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
        <button id="leaderboard" data-i18n="ui.leaderboard">–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤</button>
      </div>
      <div class="panel">
        <div class="small" data-i18n="ui.nextPiece">–°–ª–µ–¥—É—é—â–∞—è —Ñ–∏–≥—É—Ä–∞:</div>
        <div class="next-piece" id="nextPiece"></div>
      </div>
    </div>

    <div class="board-wrap">
      <button class="sound-toggle" id="soundToggle" title="–í–∫–ª—é—á–∏—Ç—å/–≤—ã–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫">üîä</button>
      <button class="pause-toggle" id="pauseToggle" title="–ü–∞—É–∑–∞">‚è∏Ô∏è</button>
      <div class="board" id="board" aria-label="–ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ">
        <div class="new-record" id="newRecord" data-i18n="game.newRecord">–ù–û–í–´–ô –†–ï–ö–û–†–î!</div>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay"><div class="modal" id="modal"></div></div>

<script>
(() => {
  // CONFIG
  const COLS = 6;
  const ROWS = 12;
  const TICK_START = 700;
  const MIN_TICK = 100;
  const SETTLE_MS = 140; // small delay before locking to avoid instant snap bug
  const AD_INTERVAL = 300000; // 5 minutes in milliseconds

  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const nextEl = document.getElementById('nextPiece');
  const overlay = document.getElementById('overlay');
  const modal = document.getElementById('modal');
  const newRecordEl = document.getElementById('newRecord');
  const appEl = document.querySelector('.app');
  const soundToggleEl = document.getElementById('soundToggle');
  const pauseToggleEl = document.getElementById('pauseToggle');
  const startScreenEl = document.getElementById('startScreen');
  const startButtonEl = document.getElementById('startButton');
  const pauseMenuEl = document.getElementById('pauseMenu');
  const resumeButtonEl = document.getElementById('resumeButton');
  const restartButtonEl = document.getElementById('restartButton');
  const soundButtonEl = document.getElementById('soundButton');
  const leaderboardButtonEl = document.getElementById('leaderboardButton');
  const leaderboardOverlayEl = document.getElementById('leaderboardOverlay');
  const leaderboardContentEl = document.getElementById('leaderboardContent');
  const leaderboardCloseEl = document.getElementById('leaderboardClose');

  let grid = [];
  let current = null;
  let nextPiece = null;
  let tick = TICK_START;
  let timer = null;
  let score = 0;
  let best = Number(localStorage.getItem('tetris2048_best') || 0);
  let paused = false;
  let settleTimer = null;
  let tileLayer = null; // will be created and appended inside createBoard
  let newRecordShown = false; // flag to prevent showing new record multiple times
  let newRecordSoundPlayed = false; // flag to prevent playing new record sound multiple times
  let comboChain = 0; // track consecutive merges
  let justPlacedBlocks = []; // track blocks that were just placed
  let gameStarted = false; // flag to track if game has started
  let currentBest = 0; // track current best score in this session
  let lastAdTime = 0; // track when last ad was shown
  let playerName = "–ò–≥—Ä–æ–∫"; // default player name
  let isAuthorized = false; // track if player is authorized
  let leaderboardData = []; // store leaderboard data
  let currentLanguage = 'ru'; // —è–∑—ã–∫ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
  let leaderboardPaused = false; // track if game is paused for leaderboard

  // flag to prevent multiple drop sounds from repeated settle attempts
  let dropSoundPending = false;

  // Yandex Games SDK variables
  let ysdk = null;
  let player = null;

  // Internationalization
  const translations = {
    ru: {
      game: {
        description: "–°–æ–µ–¥–∏–Ω—è–π—Ç–µ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –ø–ª–∏—Ç–∫–∏, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞–≤–∞—Ç—å –±–æ–ª—å—à–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è. –£–ø—Ä–∞–≤–ª—è–π—Ç–µ —Ñ–∏–≥—É—Ä–∞–º–∏ –∏ —Å–æ–∑–¥–∞–≤–∞–π—Ç–µ –∫–æ–º–±–æ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –æ—á–∫–æ–≤!",
        start: "–ù–∞—á–∞—Ç—å –∏–≥—Ä—É",
        newRecord: "–ù–û–í–´–ô –†–ï–ö–û–†–î!",
        gameOver: "–ö–æ–Ω–µ—Ü –∏–≥—Ä—ã"
      },
      pause: {
        title: "–ü–ê–£–ó–ê",
        resume: "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å",
        newGame: "–ù–æ–≤–∞—è –∏–≥—Ä–∞",
        sound: "–ó–≤—É–∫: –í–∫–ª",
        soundoff: "–ó–≤—É–∫: –í—ã–∫–ª",
        leaderboard: "–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤"
      },
      ui: {
        score: "–°—á—ë—Ç",
        best: "–†–µ–∫–æ—Ä–¥",
        newGame: "–ù–æ–≤–∞—è –∏–≥—Ä–∞",
        leaderboard: "–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤",
        nextPiece: "–°–ª–µ–¥—É—é—â–∞—è —Ñ–∏–≥—É—Ä–∞:",
        playAgain: "–ò–≥—Ä–∞—Ç—å –µ—â—ë",
        close: "–ó–∞–∫—Ä—ã—Ç—å"
      },
      leaderboard: {
        title: "–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤",
        loading: "–ó–∞–≥—Ä—É–∑–∫–∞...",
        close: "–ó–∞–∫—Ä—ã—Ç—å",
        empty: "–ú–µ—Å—Ç–æ –Ω–µ –∑–∞–Ω—è—Ç–æ",
        yourPlace: "–í–∞—à–µ –º–µ—Å—Ç–æ"
      },
      praise: {
        bombastic: "–ë–û–ú–ë–ï–ó–ù–û!",
        amazing: "–ü–æ—Ç—Ä—è—Å–∞—é—â–µ!",
        excellent: "–í–µ–ª–∏–∫–æ–ª–µ–ø–Ω–æ!",
        great: "–û—Ç–ª–∏—á–Ω–æ!",
        good: "–•–æ—Ä–æ—à–æ!",
        super: "–°—É–ø–µ—Ä!",
        comboMaster: "–ö–û–ú–ë–û-–ú–ê–°–¢–ï–†!",
        classicCombo: "–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –∫–æ–º–±–æ!"
      }
    },
    en: {
      game: {
        description: "Connect identical tiles to create larger values. Control shapes and create combos for extra points!",
        start: "Start Game",
        newRecord: "NEW RECORD!",
        gameOver: "Game Over"
      },
      pause: {
        title: "PAUSE",
        resume: "Resume",
        newGame: "New Game",
        sound: "Sound: On",
        soundoff: "Sound: Off",
        leaderboard: "Leaderboard"
      },
      ui: {
        score: "Score",
        best: "Best",
        newGame: "New Game",
        leaderboard: "Leaderboard",
        nextPiece: "Next piece:",
        playAgain: "Play Again",
        close: "Close"
      },
      leaderboard: {
        title: "Leaderboard",
        loading: "Loading...",
        close: "Close",
        empty: "Position not taken",
        yourPlace: "Your position"
      },
      praise: {
        bombastic: "BOMBASTIC!",
        amazing: "Amazing!",
        excellent: "Excellent!",
        great: "Great!",
        good: "Good!",
        super: "Super!",
        comboMaster: "COMBO MASTER!",
        classicCombo: "Classic combo!"
      }
    }
  };

  // Get current language
  function getCurrentLanguage() {
    // Try to get language from Yandex SDK if available
    if (ysdk && ysdk.environment && ysdk.environment.i18n) {
      return ysdk.environment.i18n.lang;
    }
    
    // Fallback to browser language
    const browserLang = navigator.language || navigator.userLanguage;
    if (browserLang.startsWith('en')) return 'en';
    if (browserLang.startsWith('ru')) return 'ru';
    
    // Default to Russian
    return 'ru';
  }

  // Translate text
  function t(key) {
    const keys = key.split('.');
    let value = translations[currentLanguage];
    
    for (const k of keys) {
      if (value && value[k]) {
        value = value[k];
      } else {
        // Fallback to Russian if translation not found
        value = translations.ru;
        for (const k of keys) {
          if (value && value[k]) {
            value = value[k];
          } else {
            return key; // Return key if translation not found
          }
        }
        break;
      }
    }
    
    return value;
  }

  // Update all UI elements with translations
  function updateTranslations() {
    document.querySelectorAll('[data-i18n]').forEach(element => {
      const key = element.getAttribute('data-i18n');
      element.textContent = t(key);
    });
    
    
    
    // Update sound button text
    soundButtonEl.textContent = (soundEnabled ? t('pause.sound') : t('pause.soundoff'));
    
    // Update tooltips
    soundToggleEl.title = t('ui.soundToggle');
    pauseToggleEl.title = t('ui.pause');
  }

  bestEl.textContent = best;
  currentBest = best;

  // Initialize Yandex Games SDK
  function initYandexSDK() {
    return new Promise((resolve, reject) => {
      if (typeof YaGames !== 'undefined') {
        YaGames.init({
          scope: 'public_data'
        }).then(_ysdk => {
          ysdk = _ysdk;
          console.log('Yandex SDK initialized');
          
          // –û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –Ø–ó–´–ö–ê
          currentLanguage = getCurrentLanguage();
          console.log('Language detected:', currentLanguage);
          
          // Update translations after language detection
          updateTranslations();
          
          // Get player info
          player = ysdk.getPlayer({
            scopes: 'public_data'
          }).then(_player => {
            player = _player;
            playerName = player.getName() || (currentLanguage === 'en' ? "Player" : "–ò–≥—Ä–æ–∫");
            isAuthorized = player.isAuthorized();
            console.log('Player info loaded:', playerName, isAuthorized);
            
            // Get environment info
            const env = ysdk.environment;
            console.log('Environment:', env);
            
            // Call ready when all resources are loaded
            if (ysdk.features.LoadingAPI) {
              ysdk.features.LoadingAPI.ready();
              document.getElementById('startButton').style.opacity = 1;
            }
            
            resolve();
          }).catch(err => {
            console.error('Error getting player info:', err);
            
            // Get environment info even if player info fails
            const env = ysdk.environment;
            console.log('Environment:', env);
            
            // Call ready when all resources are loaded
            if (ysdk.features.LoadingAPI) {
              ysdk.features.LoadingAPI.ready();
            }
            
            resolve();
          });
        }).catch(err => {
          console.error('Error initializing Yandex SDK:', err);
          reject(err);
        });
      } else {
        console.error('Yandex SDK not available');
        reject(new Error('Yandex SDK not available'));
      }
    });
  }

  // Show ad
  function showAd() {
    if (!ysdk) return;
    
    const now = Date.now();
    if (now - lastAdTime < AD_INTERVAL) return; // Don't show ad if not enough time has passed
    
    lastAdTime = now;
    
    // Stop gameplay
    if (ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.stop();
    }
    
    // Pause game and audio
    if (timer) clearInterval(timer);
    suspendAudioSystem();
    
    // Show fullscreen ad
    ysdk.adv.showFullscreenAdv({
      callbacks: {
        onClose: () => {
          console.log('Ad closed');
          // Resume game and audio
          if (!paused && gameStarted) {
            // Start gameplay
            if (ysdk.features.GameplayAPI) {
              ysdk.features.GameplayAPI.start();
            }
            
            restartTimer();
            resumeAudioSystem();
          }
        },
        onError: (err) => {
          console.error('Ad error:', err);
          // Resume game and audio even if ad fails
          if (!paused && gameStarted) {
            // Start gameplay
            if (ysdk.features.GameplayAPI) {
              ysdk.features.GameplayAPI.start();
            }
            
            restartTimer();
            resumeAudioSystem();
          }
        }
      }
    });
  }

  // Show rewarded ad
  function showRewardedAd(callback) {
    if (!ysdk) {
      if (callback) callback(false);
      return;
    }
    
    // Stop gameplay
    if (ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.stop();
    }
    
    // Pause game and audio
    if (timer) clearInterval(timer);
    suspendAudioSystem();
    
    // Show rewarded ad
    ysdk.adv.showRewardedVideo({
      callbacks: {
        onOpen: () => console.log('Rewarded ad opened'),
        onRewarded: () => {
          console.log('Rewarded ad completed');
          if (callback) callback(true);
        },
        onClose: () => {
          console.log('Rewarded ad closed');
          // Resume game and audio
          if (!paused && gameStarted) {
            // Start gameplay
            if (ysdk.features.GameplayAPI) {
              ysdk.features.GameplayAPI.start();
            }
            
            restartTimer();
            resumeAudioSystem();
          }
          if (callback) callback(false);
        },
        onError: (err) => {
          console.error('Rewarded ad error:', err);
          // Resume game and audio even if ad fails
          if (!paused && gameStarted) {
            // Start gameplay
            if (ysdk.features.GameplayAPI) {
              ysdk.features.GameplayAPI.start();
            }
            
            restartTimer();
            resumeAudioSystem();
          }
          if (callback) callback(false);
        }
      }
    });
  }

  // Load leaderboard
  function loadLeaderboard() {
    if (!ysdk || !ysdk.leaderboards) {
      showEmptyLeaderboard();
      return Promise.resolve();
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –º–µ—Ç–æ–¥–æ–≤ —Ç–∞–±–ª–∏—Ü—ã –ª–∏–¥–µ—Ä–æ–≤
    return ysdk.isAvailableMethod('leaderboards.getEntries').then(available => {
      if (!available) {
        console.log('Leaderboards methods not available for this user');
        showEmptyLeaderboard();
        return;
      }
      
      // Get leaderboard
      return Promise.all([
        ysdk.leaderboards.getEntries('leaders', {
          quantityTop: 10,
          includeUser: false
        }),
        ysdk.leaderboards.getPlayerEntry('leaders').catch(err => {
          if (err.code === 'LEADERBOARD_PLAYER_NOT_PRESENT') {
            return null;
          }
          throw err;
        })
      ]).then(([topEntries, playerEntry]) => {
        leaderboardData = topEntries.entries;
        displayLeaderboard(leaderboardData, playerEntry ? playerEntry.rank : null);
      }).catch(err => {
        console.error('Error getting leaderboard:', err);
        showEmptyLeaderboard();
      });
    }).catch(err => {
      console.log('Error checking leaderboard availability:', err);
      showEmptyLeaderboard();
    });
  }

  // Show empty leaderboard if SDK not available
  function showEmptyLeaderboard() {
    displayLeaderboard([]);
  }

  // Display leaderboard
  function displayLeaderboard(data, userRank) {
    if (!data || data.length === 0) {
      let html = '';
      for (let i = 1; i <= 10; i++) {
        html += `
          <div class="leaderboard-item">
            <div class="leaderboard-rank">${i}</div>
            <div class="leaderboard-name">${t('leaderboard.empty')}</div>
            <div class="leaderboard-score">-</div>
          </div>
        `;
      }
      
      if (best > 0) {
        html += `
          <div class="leaderboard-separator">${t('leaderboard.yourPlace')}</div>
          <div class="leaderboard-item current-player">
            <div class="leaderboard-rank">-</div>
            <div class="leaderboard-name">${playerName}</div>
            <div class="leaderboard-score">${best}</div>
          </div>
        `;
      }
      
      leaderboardContentEl.innerHTML = html;
      return;
    }
    
    let html = '';
    let playerInList = false;
    
    // Add existing entries
    for (let i = 0; i < Math.min(10, data.length); i++) {
      const entry = data[i];
      const isCurrentPlayer = entry.player && entry.player.uniqueID === (player ? player.uniqueID : null);
      if (isCurrentPlayer) playerInList = true;
      
      html += `
        <div class="leaderboard-item ${isCurrentPlayer ? 'current-player' : ''}">
          <div class="leaderboard-rank">${entry.rank}</div>
          <div class="leaderboard-name">${entry.player ? entry.player.publicName : (currentLanguage === 'en' ? 'Anonymous' : '–ê–Ω–æ–Ω–∏–º')}</div>
          <div class="leaderboard-score">${entry.score}</div>
        </div>
      `;
    }
    
    // Fill remaining slots with empty positions
    for (let i = data.length; i < 10; i++) {
      html += `
        <div class="leaderboard-item">
          <div class="leaderboard-rank">${i + 1}</div>
          <div class="leaderboard-name">${t('leaderboard.empty')}</div>
          <div class="leaderboard-score">-</div>
        </div>
      `;
    }
    
    // Add current player if not in list and has a score
    if (!playerInList && best > 0) {
      html += `
        <div class="leaderboard-separator">${t('leaderboard.yourPlace')}</div>
        <div class="leaderboard-item current-player">
          <div class="leaderboard-rank">${userRank ? userRank : '-'}</div>
          <div class="leaderboard-name">${playerName}</div>
          <div class="leaderboard-score">${best}</div>
        </div>
      `;
    }
    
    leaderboardContentEl.innerHTML = html;
  }

  // Submit score to leaderboard
  function submitScore(score) {
    if (!ysdk || !ysdk.leaderboards || score <= 0) {
      console.log('Leaderboards not available or invalid score');
      return Promise.resolve();
    }
    
    // –í—Å–µ–≥–¥–∞ –æ–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π —Ä–µ–∫–æ—Ä–¥
    if (score > best) {
      best = score;
      bestEl.textContent = best;
      localStorage.setItem('tetris2048_best', best);
      
      if (player) {
        player.setData({ bestScore: best });
      }
      
      if (!newRecordSoundPlayed) {
        playSound('newrecord');
        newRecordSoundPlayed = true;
      }
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ—Å—Ç—É–ø–µ–Ω –ª–∏ –º–µ—Ç–æ–¥ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å—á–µ—Ç–∞
    return ysdk.isAvailableMethod('leaderboards.setScore').then(available => {
      if (!available) {
        console.log('Leaderboard setScore method not available for this user');
        return;
      }
      
      // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â—É—é –∑–∞–ø–∏—Å—å –∏–≥—Ä–æ–∫–∞
      return ysdk.leaderboards.getPlayerEntry('leaders')
        .then(currentEntry => {
          // –ï—Å–ª–∏ –∑–∞–ø–∏—Å—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ —Ç–µ–∫—É—â–∏–π —Å—á–µ—Ç –ª—É—á—à–µ - –æ–±–Ω–æ–≤–ª—è–µ–º
          if (!currentEntry || score >= currentEntry.score) {
            return ysdk.leaderboards.setScore('leaders', score);
          }
        })
        .then(() => {
          console.log('Score successfully updated in leaderboard:', score);
        })
        .catch(err => {
          // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—à–∏–±–∫—É, –∫–æ–≥–¥–∞ –∏–≥—Ä–æ–∫ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ —Ç–∞–±–ª–∏—Ü–µ –ª–∏–¥–µ—Ä–æ–≤
          if (err.code === 'LEADERBOARD_PLAYER_NOT_PRESENT') {
            console.log('Player not present in leaderboard, adding player...');
            // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, –ø—Ä–æ—Å—Ç–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—á–µ—Ç
            return ysdk.leaderboards.setScore('leaders', score)
              .then(() => {
                console.log('Player added to leaderboard with score:', score);
              });
          } else if (err.code === 'LEADERBOARD_TOO_MANY_REQUESTS') {
            console.log('Too many requests, retrying in 1 second');
            setTimeout(() => submitScore(score), 1000);
          } else if (err.code === 'NETWORK_ERROR') {
            console.log('Network error, retrying in 2 seconds');
            setTimeout(() => submitScore(score), 2000);
          } else {
            console.error('Error updating leaderboard score:', err);
          }
        });
    }).catch(err => {
      console.log('Error checking leaderboard availability:', err);
    });
  }

  // Responsive scaling function
  function updateScale() {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    const normalWidth = 620;
    const normalHeight = 615;
    const largeWidth = 1000;
    const largeHeight = 650;
    const minSize = 320;
    
    // Calculate scale based on window size
    let scale;
    
    if (windowWidth < normalWidth || windowHeight < normalHeight) {
      // Window is smaller than normal dimensions - decrease scale
      const scaleX = Math.max(minSize / normalWidth, windowWidth / normalWidth);
      const scaleY = Math.max(minSize / normalHeight, windowHeight / normalHeight);
      scale = Math.min(scaleX, scaleY);
    } else if (windowWidth >= largeWidth && windowHeight >= largeHeight) {
      // Window is larger than large dimensions - increase scale to fill the screen
      const scaleX = windowWidth / largeWidth;
      const scaleY = windowHeight / largeHeight;
      scale = Math.min(scaleX, scaleY);
    } else {
      // Window is between normal and large dimensions - keep scale at 1
      scale = 1;
    }
    
    // Apply scale to CSS variable
    document.documentElement.style.setProperty('--scale', scale);
  }

  // Initial scale calculation
  updateScale();
  
  // Update scale on window resize
  window.addEventListener('resize', updateScale);

  // WebAudio API Sound System
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  const sounds = {};
  let soundEnabled = true;
  let bgMusicSource = null;
  let bgMusicGainNode = null;
  
  // –ó–∞–≥—Ä—É–∑–∫–∞ –∑–≤—É–∫–æ–≤
  function loadSounds() {
    // –°–æ–∑–¥–∞–µ–º –ø—É—Å—Ç—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∑–≤—É–∫–æ–≤, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–æ–∫ –¥–æ –∏—Ö –∑–∞–≥—Ä—É–∑–∫–∏
    sounds.move = () => {};
    sounds.rotate = () => {};
    sounds.drop = () => {};
    sounds.merge = () => {};
    sounds.combo = () => {};
    sounds.megacombo = () => {};
    sounds.gameover = () => {};
    sounds.newrecord = () => {};
    sounds.background = () => {};

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –∑–≤—É–∫–∏ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
    loadSound('move.mp3').then(sound => { if (sound) sounds.move = sound; });
    loadSound('rotate.mp3').then(sound => { if (sound) sounds.rotate = sound; });
    loadSound('drop.mp3').then(sound => { if (sound) sounds.drop = sound; });
    loadSound('merge.mp3').then(sound => { if (sound) sounds.merge = sound; });
    loadSound('combo.mp3').then(sound => { if (sound) sounds.combo = sound; });
    loadSound('megacombo.mp3').then(sound => { if (sound) sounds.megacombo = sound; });
    loadSound('gameover.mp3').then(sound => { if (sound) sounds.gameover = sound; });
    loadSound('newrecord.mp3').then(sound => { if (sound) sounds.newrecord = sound; });
    // background handled separately because we use looping bufferSource
    // but keep a loaded buffer as convenience
    loadSoundBuffer('background.mp3').then(buffer => { if (buffer) sounds.backgroundBuffer = buffer; });
  }
  
  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∑–≤—É–∫–∞ –∏ –≤–æ–∑–≤—Ä–∞—Ç–∞ —Ñ—É–Ω–∫—Ü–∏–∏-–≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
  function loadSound(url) {
    return fetch(url)
      .then(response => {
        if (!response.ok) throw new Error('not found');
        return response.arrayBuffer();
      })
      .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
      .then(audioBuffer => {
        return () => {
          if (!soundEnabled) return;
          // don't attempt to start audioContext if suspended
          if (audioContext.state === 'suspended') return;
          
          const source = audioContext.createBufferSource();
          source.buffer = audioBuffer;
          
          const gainNode = audioContext.createGain();
          gainNode.gain.value = 0.7;
          
          source.connect(gainNode);
          gainNode.connect(audioContext.destination);
          source.start();
        };
      })
      .catch(error => {
        console.warn('Error loading sound:', url, error);
        return null;
      });
  }

  // load background buffer for looped playback
  function loadSoundBuffer(url){
    return fetch(url)
      .then(response => {
        if (!response.ok) throw new Error('not found');
        return response.arrayBuffer();
      })
      .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
      .catch(err => { console.warn('bg load err', err); return null; });
  }

  // –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∑–≤—É–∫–∞
  function playSound(soundName) {
    if (!soundEnabled) return;
    if (audioContext.state === 'suspended') return;
    if (sounds[soundName]) {
      try { sounds[soundName](); } catch(e){ /* ignore */ }
    }
  }
  
  // –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Ñ–æ–Ω–æ–≤–æ–π –º—É–∑—ã–∫–∏ –≤ —Ü–∏–∫–ª–µ (—Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ä–∞–Ω–µ–µ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ –±—É—Ñ–µ—Ä–∞)
  function playBackgroundMusic() {
    if (!soundEnabled) return;
    if (audioContext.state === 'suspended') return;
    stopBackgroundMusic();
    if (!sounds.backgroundBuffer) {
      // –µ—Å–ª–∏ –±—É—Ñ–µ—Ä –µ—â—ë –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω, –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –∑–∞–ø—É—Å—Ç–∏—Ç—å fetch-–ø—Ä–æ—Ü–µ—Å—Å:
      loadSoundBuffer('background.mp3').then(buffer => {
        if (!buffer) return;
        sounds.backgroundBuffer = buffer;
        _startBgFromBuffer(buffer);
      }).catch(()=>{});
      return;
    }
    _startBgFromBuffer(sounds.backgroundBuffer);
  }
  function _startBgFromBuffer(buffer){
    try {
      bgMusicSource = audioContext.createBufferSource();
      bgMusicSource.buffer = buffer;
      bgMusicSource.loop = true;
      bgMusicGainNode = audioContext.createGain();
      bgMusicGainNode.gain.value = 0.3;
      bgMusicSource.connect(bgMusicGainNode);
      bgMusicGainNode.connect(audioContext.destination);
      bgMusicSource.start(0);
    } catch(e){
      console.warn('bg start error', e);
    }
  }
  
  // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ñ–æ–Ω–æ–≤–æ–π –º—É–∑—ã–∫–∏
  function stopBackgroundMusic() {
    if (bgMusicSource) {
      try { bgMusicSource.stop(); } catch(e) {}
      bgMusicSource = null;
    }
    if (bgMusicGainNode) {
      try { bgMusicGainNode.disconnect(); } catch(e) {}
      bgMusicGainNode = null;
    }
  }
  
  // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –∑–≤—É–∫–∞ (UI-–∫–Ω–æ–ø–∫–∞)
  function toggleSound() {
    soundEnabled = !soundEnabled;
    soundToggleEl.textContent = soundEnabled ? 'üîä' : 'üîá';
    soundToggleEl.classList.toggle('muted', !soundEnabled);
    soundButtonEl.textContent =  (soundEnabled ? t('pause.sound') : t('pause.soundoff'));
    
    if (soundEnabled) {
      // –µ—Å–ª–∏ –∞—É–¥–∏–æ-–∫–æ–Ω—Ç–µ–∫—Å—Ç –±—ã–ª suspended –∏–∑-–∑–∞ –ø–∞—É–∑—ã, –Ω–µ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ resume –∑–¥–µ—Å—å
      if (audioContext.state === 'suspended') {
        audioContext.resume().then(()=>{
          if (!paused && gameStarted) playBackgroundMusic();
        });
      } else {
        if (!paused && gameStarted) playBackgroundMusic();
      }
    } else {
      stopBackgroundMusic();
    }
  }
  
  // –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Å—ë –∞—É–¥–∏–æ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä–∏ –ø–∞—É–∑–µ)
  function suspendAudioSystem() {
    stopBackgroundMusic();
    // suspend audio context to halt any sources
    if (audioContext && audioContext.state === 'running') {
      audioContext.suspend().catch(()=>{});
    }
  }
  // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∞—É–¥–∏–æ –ø–æ—Å–ª–µ –ø–∞—É–∑—ã
  function resumeAudioSystem() {
    if (audioContext && audioContext.state === 'suspended') {
      audioContext.resume().then(()=>{ if (soundEnabled && gameStarted) playBackgroundMusic(); }).catch(()=>{});
    } else {
      if (soundEnabled && gameStarted) playBackgroundMusic();
    }
  }

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –∑–≤—É–∫–∞
  soundToggleEl.addEventListener('click', toggleSound);
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–≤—É–∫–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã
  loadSounds();

  // shapes
  const SHAPES = {
    I: [[0,1],[1,1],[2,1],[3,1]],
    O: [[0,0],[1,0],[0,1],[1,1]],
    T: [[0,1],[1,1],[2,1],[1,0]],
    L: [[0,0],[0,1],[0,2],[1,2]],
    J: [[1,0],[1,1],[1,2],[0,2]],
    S: [[0,1],[1,1],[1,0],[2,0]],
    Z: [[0,0],[1,0],[1,1],[2,1]]
  };
  const SHAPE_KEYS = Object.keys(SHAPES);

  // DOM helpers: grid background cells
  function createBoard(){
    boardEl.style.setProperty('--cols', COLS);
    boardEl.style.setProperty('--rows', ROWS);
    boardEl.innerHTML = `<div class="new-record" id="newRecord">${t('game.newRecord')}</div>`;
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const bg = document.createElement('div');
        bg.className = 'cell-bg';
        bg.dataset.r = r; bg.dataset.c = c;
        boardEl.appendChild(bg);
      }
    }
    // create/attach tileLayer for absolute positioned animated tiles
    if (!tileLayer){
      tileLayer = document.createElement('div');
      tileLayer.style.position = 'absolute';
      tileLayer.style.inset = '12px';
      tileLayer.style.pointerEvents = 'none';
    }
    tileLayer.innerHTML = '';
    boardEl.appendChild(tileLayer);
  }

  function resetGrid(){ grid = Array.from({length:ROWS},()=>Array(COLS).fill(0)); }

  function randInitialValue(){ const r = Math.random(); if (r<0.7) return 2; if (r<0.95) return 4; return 8; }

  function makePiece(shapeKey=null){
    const key = shapeKey || SHAPE_KEYS[Math.floor(Math.random()*SHAPE_KEYS.length)];
    const blocks = SHAPES[key].map(p=>({x:p[0], y:p[1], v: randInitialValue()}));
    const minX = Math.min(...blocks.map(b=>b.x));
    const maxX = Math.max(...blocks.map(b=>b.x));
    const width = maxX-minX+1;
    const offsetX = Math.floor((COLS-width)/2) - minX;
    const offsetY = -Math.max(...blocks.map(b=>b.y)) - 1;
    return {blocks, x:offsetX, y:offsetY, key};
  }

  function cellMetrics(){
    const style = getComputedStyle(document.documentElement);
    const cell = parseFloat(style.getPropertyValue('--cell-size')) ;
    const gap = parseFloat(style.getPropertyValue('--gap'));
    const padding = 12; // board padding
    return {cell, gap, padding};
  }

  // Manage tile elements by id key 'r-c' for grid, and 'cur-i' for current moving
  function ensureTile(id, val){
    if (!tileLayer) return null;
    let el = tileLayer.querySelector(`[data-id='${id}']`);
    if (!el){
      el = document.createElement('div');
      el.className = 'tile-el';
      el.setAttribute('data-id', id);
      el.innerHTML = `<div class='label'></div>`;
      tileLayer.appendChild(el);
    }
    el.setAttribute('data-val', val);
    el.querySelector('.label').textContent = val;
    return el;
  }

  function removeTile(id){ if (!tileLayer) return; const el = tileLayer.querySelector(`[data-id='${id}']`); if (el) el.remove(); }

  // Draw function: update tiles to reflect grid + current piece
  function draw(){
    const {cell,gap,padding} = cellMetrics();
    const tileIds = new Set();

    if (!tileLayer) return;

    // draw grid
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
      const v = grid[r][c];
      const id = `g-${r}-${c}`;
      if (v){
        const el = ensureTile(id, v);
        if (!el) continue;
        tileIds.add(id);
        const left = c*(cell+gap);
        const top = r*(cell+gap);
        el.style.left = `${left}px`;
        el.style.top = `${top}px`;
        el.style.width = `${cell}px`;
        el.style.height = `${cell}px`;
      } else {
        removeTile(id);
      }
    }

    // draw current piece
    if (current){
      current.blocks.forEach((b, idx)=>{
        const r = current.y + b.y;
        const c = current.x + b.x;
        const id = `cur-${idx}`;
        const val = b.v;
        const el = ensureTile(id, val);
        if (!el) return;
        tileIds.add(id);
        const left = c*(cell+gap);
        const top = r*(cell+gap);
        el.style.left = `${left}px`;
        el.style.top = `${top}px`;
        el.style.width = `${cell}px`;
        el.style.height = `${cell}px`;
      });
    } else {
      // remove any cur-* tiles that remained
      tileLayer.querySelectorAll('[data-id^="cur-"]').forEach(e=>e.remove());
    }

    // cleanup orphan tiles
    tileLayer.querySelectorAll('[data-id]').forEach(el=>{
      const id = el.getAttribute('data-id');
      if (!tileIds.has(id)) el.remove();
    });
  }

  // Next preview (simple grid cells)
  function drawNext(){
    nextEl.innerHTML = '';
    for (let i=0;i<16;i++){ const d = document.createElement('div'); d.className='cell-bg'; nextEl.appendChild(d);}    
    if (!nextPiece) return;
    nextPiece.blocks.forEach(b=>{
      const r = b.y + 1; const c = b.x + 1; const idx = r*4 + c;
      if (idx>=0 && idx<nextEl.children.length){
        const el = nextEl.children[idx];
        el.className = '';
        el.style.borderRadius='8px';
        el.textContent = b.v; el.style.fontWeight = 800; el.style.display='flex'; el.style.alignItems='center'; el.style.justifyContent='center';
        el.style.background = "#f1efe9";
        el.style.color = "black";
      }
    });
  }

  function collides(x,y,blocks){
    for (const b of blocks){
      const r = y + b.y;
      const c = x + b.x;
      if (c<0 || c>=COLS) return true;
      if (r>=ROWS) return true;
      if (r>=0 && grid[r][c]) return true;
    }
    return false;
  }

  function move(dx, dy, playMoveSound = false){
    if (!current) return false;
    if (!collides(current.x + dx, current.y + dy, current.blocks)){
      current.x += dx; current.y += dy; 
      if (playMoveSound) {
        playSound('move'); // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–æ
      }
      draw(); 
      return true;
    }
    return false;
  }

  function rotate(){
    if (!current) return;
    const newBlocks = current.blocks.map(b=>({x: b.y, y: -b.x, v: b.v}));
    const minX = Math.min(...newBlocks.map(b=>b.x));
    const minY = Math.min(...newBlocks.map(b=>b.y));
    newBlocks.forEach(b=>{ b.x -= minX; b.y -= minY; });
    if (!collides(current.x, current.y, newBlocks)){
      current.blocks = newBlocks; 
      playSound('rotate'); // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ –≤—Ä–∞—â–µ–Ω–∏—è
      draw();
    } else {
      if (!collides(current.x-1, current.y, newBlocks)) { current.x -=1; current.blocks=newBlocks; draw(); }
      else if (!collides(current.x+1, current.y, newBlocks)) { current.x +=1; current.blocks=newBlocks; draw(); }
    }
  }

  function hardDrop(){
    if (!current) return;
    while(move(0,1, false)){}
    playSound('drop'); // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ –ø–∞–¥–µ–Ω–∏—è
    lockPiece();
  }

  // –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã—Ö —Å–ª–∏—è–Ω–∏–π
  function checkHorizontalMerges(placedBlocks) {
    const mergedCells = [];
    const processed = new Set();
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π –±–ª–æ–∫, –∫–æ—Ç–æ—Ä—ã–π –±—ã–ª —Ç–æ–ª—å–∫–æ —á—Ç–æ —Ä–∞–∑–º–µ—â–µ–Ω
    for (const [r, c] of placedBlocks) {
      const key = `${r},${c}`;
      if (processed.has(key)) continue;
      
      const val = grid[r][c];
      if (!val) continue;
      
      // –ò—â–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Å–≤—è–∑–Ω–æ—Å—Ç–∏ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏ (—Å–ª–µ–≤–∞ –∏ —Å–ø—Ä–∞–≤–∞)
      const component = [];
      const queue = [[r, c]];
      processed.add(key);
      
      while (queue.length > 0) {
        const [cr, cc] = queue.shift();
        component.push([cr, cc]);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã—Ö —Å–æ—Å–µ–¥–µ–π (—Å–ª–µ–≤–∞ –∏ —Å–ø—Ä–∞–≤–∞)
        const left = cc - 1;
        const right = cc + 1;
        
        if (left >= 0 && grid[cr][left] === val && !processed.has(`${cr},${left}`)) {
          processed.add(`${cr},${left}`);
          queue.push([cr, left]);
        }
        
        if (right < COLS && grid[cr][right] === val && !processed.has(`${cr},${right}`)) {
          processed.add(`${cr},${right}`);
          queue.push([cr, right]);
        }
      }
      
      // –ï—Å–ª–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç 2 –∏–ª–∏ –±–æ–ª–µ–µ –ø–ª–∏—Ç–∫–∏, –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ –≤ —Å–ø–∏—Å–æ–∫ –¥–ª—è —Å–ª–∏—è–Ω–∏—è
      if (component.length >= 2) {
        mergedCells.push(component);
      }
    }
    
    return mergedCells;
  }

  // –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã—Ö —Å–ª–∏—è–Ω–∏–π
  function performHorizontalMerges(mergedComponents) {
    const anims = [];
    
    for (const component of mergedComponents) {
      if (component.length < 2) continue;
      
      const val = grid[component[0][0]][component[0][1]];
      
      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –º–Ω–æ–∂–∏—Ç–µ–ª—å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
      let multiplier;
      if (component.length === 2) multiplier = 2;
      else if (component.length === 3) multiplier = 2;
      else multiplier = 4;
      
      const mergedVal = val * multiplier;
      
      // –í—ã–±–∏—Ä–∞–µ–º —è—á–µ–π–∫—É –¥–ª—è —Å–ª–∏—è–Ω–∏—è - –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–æ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—É—é
      const centerIndex = Math.floor(component.length / 2);
      const [mr, mc] = component[centerIndex];
      
      // –û—á–∏—â–∞–µ–º –≤—Å–µ —è—á–µ–π–∫–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
      for (const [r, c] of component) {
        grid[r][c] = 0;
      }
      
      // –†–∞–∑–º–µ—â–∞–µ–º –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω—É—é –ø–ª–∏—Ç–∫—É
      grid[mr][mc] = mergedVal;
      
      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç
      score += mergedVal;
      updateScoreAndLevel();
      
      anims.push({r: mr, c: mc, val: mergedVal, size: component.length});
      playSound('merge');
    }
    
    return anims;
  }

  // –ù–æ–≤–∞—è –º–µ—Ö–∞–Ω–∏–∫–∞ —Å–ª–∏—è–Ω–∏—è (—Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è):
  // processMerges(optionalLimitSet):
  // - –µ—Å–ª–∏ optionalLimitSet –∑–∞–¥–∞–Ω (Set —Å—Ç—Ä–æ–∫–æ–≤—ã—Ö –∫–ª—é—á–µ–π "r,c"), —Ç–æ –±—É–¥—É—Ç –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã —Ç–æ–ª—å–∫–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø–µ—Ä–µ—Å–µ–∫–∞—é—Ç—Å—è —Å —ç—Ç–∏–º –º–Ω–æ–∂–µ—Å—Ç–≤–æ–º (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ —Å–ª–∏—è–Ω–∏—è)
  // - –∏–Ω–∞—á–µ ‚Äî –ø–æ–ª–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ –≤—Å–µ–º—É –ø–æ–ª—é.
  function processMerges(limitSet = null){
    let anyMerged = false;
    const anims = [];
    const visited = Array.from({length:ROWS},()=>Array(COLS).fill(false));
    
    // helper to get neighbors
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (visited[r][c] || !grid[r][c]) continue;
        
        // BFS component of equal-value tiles
        const val = grid[r][c];
        const component = [];
        const queue = [[r,c]];
        visited[r][c] = true;
        while(queue.length){
          const [cr, cc] = queue.shift();
          component.push([cr, cc]);
          for (const [dr, dc] of dirs){
            const nr = cr + dr; const nc = cc + dc;
            if (nr<0||nr>=ROWS||nc<0||nc>=COLS) continue;
            if (visited[nr][nc] || grid[nr][nc] !== val) continue;
            visited[nr][nc] = true;
            queue.push([nr, nc]);
          }
        }

        // if limitSet is provided and component doesn't intersect it -> skip
        if (limitSet){
          let intersects = false;
          for (const [cr,cc] of component){
            if (limitSet.has(`${cr},${cc}`)){ intersects = true; break; }
          }
          if (!intersects) continue;
        }

        if (component.length >= 2){
          anyMerged = true;

          // multiplier logic preserved
          let multiplier;
          if (component.length === 2) multiplier = 2;
          else if (component.length === 3) multiplier = 2;
          else multiplier = 4;

          const mergedVal = val * multiplier;

          // choose merge cell: prefer the cell in component that has the most non-component neighbors
          // (this biases towards side –±–ª–∏–∂–µ –∫ –¥—Ä—É–≥–∏–º –ø–ª–∏—Ç–∫–∞–º)
          const neighborCounts = component.map(([cr,cc])=>{
            let count = 0;
            for (const [dr,dc] of dirs){
              const nr = cr + dr, nc = cc + dc;
              if (nr<0||nr>=ROWS||nc<0||nc>=COLS) continue;
              // count neighbors that are non-zero and not part of this component
              if (grid[nr][nc] && !component.some(p => p[0]===nr && p[1]===nc)) count++;
            }
            return count;
          });

          // find best index: highest neighborCounts; tie-breaker: higher row (smaller r), then closer to center
          let bestIdx = 0;
          for (let i=1;i<component.length;i++){
            if (neighborCounts[i] > neighborCounts[bestIdx]) bestIdx = i;
            else if (neighborCounts[i] === neighborCounts[bestIdx]){
              // prefer higher (smaller r)
              if (component[i][0] < component[bestIdx][0]) bestIdx = i;
              else if (component[i][0] === component[bestIdx][0]){
                const centerCol = Math.floor(COLS/2);
                const distI = Math.abs(component[i][1] - centerCol);
                const distB = Math.abs(component[bestIdx][1] - centerCol);
                if (distI < distB) bestIdx = i;
              }
            }
          }

          // clear all component cells
          for (const [cr, cc] of component) grid[cr][cc] = 0;

          const [mr, mc] = component[bestIdx];
          grid[mr][mc] = mergedVal;

          // score update
          score += mergedVal;
          updateScoreAndLevel();

          anims.push({r: mr, c: mc, val: mergedVal, size: component.length});
          playSound('merge');
        }
      }
    }

    return {anyMerged, anims};
  }

  function applyGravity(){
    for (let c=0;c<COLS;c++){
      let write = ROWS-1;
      for (let r=ROWS-1;r>=0;r--){
        if (grid[r][c]){
          if (r !== write){ grid[write][c] = grid[r][c]; grid[r][c] = 0; }
          write--;
        }
      }
    }
  }

  // animate merges: pop, spawn particles, show praise
  function animateMerges(anims){
    if (!anims || anims.length===0) return;
    const {cell,gap} = cellMetrics();
    for (const a of anims){
      const id = `g-${a.r}-${a.c}`;
      const el = tileLayer.querySelector(`[data-id='${id}']`);
      if (el){
        el.classList.add('merge-anim');
        setTimeout(()=>el.classList.remove('merge-anim'), 520);
      }
      // spawn particles
      const originLeft = a.c*(cell+gap) + cell/2;
      const originTop = a.r*(cell+gap) + cell/2;
      spawnParticles(originLeft, originTop, Math.min(12, 3 + Math.floor(a.size/2)));
      // show praise
      const praise = choosePraise(a.val, a.size);
      showPraise(praise, originLeft, originTop);
    }
  }

  function spawnParticles(x,y,count){
    for (let i=0;i<count;i++){
      const p = document.createElement('div');
      p.className = 'particle';
      p.style.left = `${x - 5}px`;
      p.style.top = `${y - 5}px`;
      // random direction
      const angle = (Math.random()*Math.PI*2);
      const dist = 40 + Math.random()*40;
      const dx = Math.cos(angle)*dist + 'px';
      const dy = Math.sin(angle)*dist - 20 + 'px';
      p.style.setProperty('--dx', dx);
      p.style.setProperty('--dy', dy);
      const dur = 700 + Math.random()*300;
      p.style.animation = `starFly ${dur}ms cubic-bezier(.2,.9,.2,1) forwards`;
      tileLayer.appendChild(p);
      // remove after animation
      setTimeout(()=>{ p.remove(); }, dur + 50);
    }
  }

  function choosePraise(val, size){
    // bigger merges get stronger praise
    if (val >= 1024) return t('praise.bombastic');
    if (val >= 512) return t('praise.amazing');
    if (val >= 128) return t('praise.excellent');
    if (size >= 4) return t('praise.great');
    if (size >= 3) return t('praise.good');
    return t('praise.super');
  }

  function showPraise(text, x, y){
    const p = document.createElement('div');
    p.className = 'praise';
    p.textContent = text;
    // position relative to tileLayer
    p.style.left = `${x}px`;
    p.style.top = `${y}px`;
    tileLayer.appendChild(p);
    // force reflow then show
    requestAnimationFrame(()=>{ p.classList.add('show'); });
    setTimeout(()=>{ p.classList.remove('show'); setTimeout(()=>p.remove(),500); }, 1200);
  }

  function showCombo(count, x, y){
    if (count <= 1) return;
    
    // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º —Ä–∞–∑–Ω—ã–µ –∑–≤—É–∫–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ –∫–æ–º–±–æ
    if (count > 4) {
      playSound('megacombo'); // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ –º–µ–≥–∞-–∫–æ–º–±–æ
    } else {
      playSound('combo'); // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –æ–±—ã—á–Ω—ã–π –∑–≤—É–∫ –∫–æ–º–±–æ
    }
    
    const p = document.createElement('div');
    p.className = 'combo';
    p.textContent = `COMBO x${count}`;
    p.style.left = `${x}px`;
    p.style.top = `${y - 20}px`;
    tileLayer.appendChild(p);
    requestAnimationFrame(()=>{ p.classList.add('show'); });
    setTimeout(()=>{ p.classList.remove('show'); setTimeout(()=>p.remove(),400); }, 1000);
  }

  function showNewRecord() {
    if (newRecordShown) return;
    newRecordShown = true;
    
    // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ –Ω–æ–≤–æ–≥–æ —Ä–µ–∫–æ—Ä–¥–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω –µ—â–µ –Ω–µ –±—ã–ª –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω –Ω–∞ —ç—Ç–æ–º —É—Ä–æ–≤–Ω–µ
    if (!newRecordSoundPlayed) {
      playSound('newrecord'); // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ –Ω–æ–≤–æ–≥–æ —Ä–µ–∫–æ—Ä–¥–∞
      newRecordSoundPlayed = true;
    }
    
    const newRecordEl = document.getElementById('newRecord');
    newRecordEl.classList.add('show');
    setTimeout(() => {
      newRecordEl.classList.remove('show');
      // –ù–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º newRecordShown –∑–¥–µ—Å—å, —á—Ç–æ–±—ã —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –Ω–µ –ø–æ—è–≤–ª—è–ª–æ—Å—å —Å–Ω–æ–≤–∞
    }, 3000);
  }

  // –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê: —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Å–ª–∏—è–Ω–∏–π –±–µ–∑ –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏
  function performAllMerges() {
    let totalMerges = 0;
    let totalAnims = [];
    
    function mergeLoop() {
      const res = processMerges();
      if (res.anyMerged) {
        totalMerges++;
        comboChain++;
        totalAnims = totalAnims.concat(res.anims);
        
        // –ê–Ω–∏–º–∏—Ä—É–µ–º —Ç–µ–∫—É—â–∏–µ —Å–ª–∏—è–Ω–∏—è
        draw();
        animateMerges(res.anims);
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–º–±–æ –¥–ª—è —Ü–µ–ø–æ—á–∫–∏ —Å–ª–∏—è–Ω–∏–π
        if (res.anims && res.anims.length > 0) {
          const a = res.anims[0];
          const {cell,gap} = cellMetrics();
          const originLeft = a.c*(cell+gap) + cell/2;
          const originTop = a.r*(cell+gap) + cell/2;
          showCombo(comboChain, originLeft, originTop);
        }
        
        // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø—Ä–æ–≤–µ—Ä—è—Ç—å —Å–ª–∏—è–Ω–∏—è
        setTimeout(mergeLoop, 420);
      } else {
        // –í—Å–µ —Å–ª–∏—è–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω—ã, –ø—Ä–∏–º–µ–Ω—è–µ–º –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—é
        setTimeout(() => {
          applyGravity();
          draw();
          
          // –ü–æ—Å–ª–µ –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø–æ—è–≤–∏–ª–∏—Å—å –ª–∏ –Ω–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–ª—è —Å–ª–∏—è–Ω–∏—è
          setTimeout(() => {
            const afterGravityRes = processMerges();
            if (afterGravityRes.anyMerged) {
              // –ï—Å–ª–∏ –ø–æ—Å–ª–µ –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏ –µ—Å—Ç—å –Ω–æ–≤—ã–µ —Å–ª–∏—è–Ω–∏—è, –∑–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å –∑–∞–Ω–æ–≤–æ
              performAllMerges();
            } else {
              // –í—Å–µ —Å–ª–∏—è–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω—ã, —Å–ø–∞–≤–Ω–∏–º —Å–ª–µ–¥—É—é—â—É—é —Ñ–∏–≥—É—Ä—É
              if (comboChain > 1){
                const centerX = (COLS/2) * (cellMetrics().cell + cellMetrics().gap);
                const centerY = (ROWS/3) * (cellMetrics().cell + cellMetrics().gap);
                showPraise(comboChain >= 4 ? t('praise.comboMaster') : t('praise.classicCombo'), centerX, centerY);
              }
              spawnNext();
            }
          }, 220);
        }, totalMerges > 0 ? 420 : 0);
      }
    }
    
    mergeLoop();
  }

  // lockPiece: –ø—Ä–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–µ –≤—ã–ø–æ–ª–Ω—è–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ –±–æ–∫–æ–≤—ã–µ —Å–ª–∏—è–Ω–∏—è –≤–æ–∫—Ä—É–≥ —Ç–æ–ª—å–∫–æ —á—Ç–æ —É–ø–∞–≤—à–∏—Ö –±–ª–æ–∫–æ–≤,
  // –∑–∞—Ç–µ–º –ø—Ä–∏–º–µ–Ω—è–µ–º –Ω–æ–≤—É—é –ª–æ–≥–∏–∫—É —Å–ª–∏—è–Ω–∏–π
  function lockPiece(){
    if (!current) return;
    
    // –û—á–∏—â–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ç–æ–ª—å–∫–æ —á—Ç–æ —É–ø–∞–≤—à–∏—Ö –±–ª–æ–∫–æ–≤
    justPlacedBlocks = [];
    
    // place into grid
    for (const b of current.blocks){
      const r = current.y + b.y; 
      const c = current.x + b.x;
      if (r<0) { return gameOver(); }
      grid[r][c] = b.v;
      justPlacedBlocks.push([r, c]);
    }

    current = null;
    // –ù–ï —Å–±—Ä–∞—Å—ã–≤–∞–µ–º comboChain –∑–¥–µ—Å—å, —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –µ–≥–æ –º–µ–∂–¥—É –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–º–∏ –∏ –ø–æ—Å–ª–µ–¥—É—é—â–∏–º–∏ —Å–ª–∏—è–Ω–∏—è–º–∏

    // ---------- –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê: —Å–Ω–∞—á–∞–ª–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ —Å–ª–∏—è–Ω–∏—è, –∑–∞—Ç–µ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å–ª–∏—è–Ω–∏—è ----------
    
    // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –∏ –≤—ã–ø–æ–ª–Ω—è–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ —Å–ª–∏—è–Ω–∏—è
    const horizontalMerges = checkHorizontalMerges(justPlacedBlocks);
    let horizontalMergeAnims = [];
    
    if (horizontalMerges.length > 0) {
      horizontalMergeAnims = performHorizontalMerges(horizontalMerges);
      // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º comboChain —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω –µ—â–µ –Ω–µ –±—ã–ª —É–≤–µ–ª–∏—á–µ–Ω
      if (comboChain === 0) comboChain = 1;
      draw();
      animateMerges(horizontalMergeAnims);
      
      // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–º–±–æ –¥–ª—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã—Ö —Å–ª–∏—è–Ω–∏–π
      if (horizontalMergeAnims.length > 0) {
        const a = horizontalMergeAnims[0];
        const {cell,gap} = cellMetrics();
        const originLeft = a.c*(cell+gap) + cell/2;
        const originTop = a.r*(cell+gap) + cell/2;
        showCombo(comboChain, originLeft, originTop);
      }
      
      // –ü–æ—Å–ª–µ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã—Ö —Å–ª–∏—è–Ω–∏–π –ø—Ä–∏–º–µ–Ω—è–µ–º –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—é
      setTimeout(() => {
        applyGravity();
        draw();
        
        // –ó–∞—Ç–µ–º –∑–∞–ø—É—Å–∫–∞–µ–º –ø–æ–ª–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å —Å–ª–∏—è–Ω–∏–π
        setTimeout(() => {
          performAllMerges();
        }, 220);
      }, 420);
    } else {
      // –ï—Å–ª–∏ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã—Ö —Å–ª–∏—è–Ω–∏–π –Ω–µ—Ç, —Å—Ä–∞–∑—É –∑–∞–ø—É—Å–∫–∞–µ–º –ø–æ–ª–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å —Å–ª–∏—è–Ω–∏–π
      comboChain = 0; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º comboChain —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –±—ã–ª–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã—Ö —Å–ª–∏—è–Ω–∏–π
      performAllMerges();
    }
  }

  function spawnNext(){
    if (!nextPiece) nextPiece = makePiece();
    current = {blocks: nextPiece.blocks.map(b=>({x:b.x,y:b.y,v:b.v})), x: nextPiece.x, y: nextPiece.y, key: nextPiece.key};
    nextPiece = makePiece();
    drawNext();
    draw();
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ü–µ–ø–æ—á–∫—É –∫–æ–º–±–æ –ø—Ä–∏ –ø–æ—è–≤–ª–µ–Ω–∏–∏ –Ω–æ–≤–æ–π —Ñ–∏–≥—É—Ä—ã
    comboChain = 0;
    // if immediately collides -> game over
    if (collides(current.x, current.y, current.blocks)){
      gameOver();
    }
  }

  function updateScoreAndLevel(){
    scoreEl.textContent = score;
    restartTimer();
    if (score > best){ 
      best = score; 
      bestEl.textContent = best; 
      localStorage.setItem('tetris2048_best', best); 
      // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–æ–≤—ã–π —Ä–µ–∫–æ—Ä–¥ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ç–µ–∫—É—â–∏–π —Å—á–µ—Ç –ø—Ä–µ–≤—ã—Å–∏–ª –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ä–µ–∫–æ—Ä–¥
      if (score > currentBest) {
        showNewRecord();
        currentBest = score;
      }
    }
  }

  function step(){
    if (paused || leaderboardPaused) return;
    if (!current) return;
    // try move down without playing sound
    if (move(0,1, false)){
      // cancel settle if moving
      if (settleTimer){ clearTimeout(settleTimer); settleTimer = null; dropSoundPending = false; }
      draw();
    } else {
      // cannot move down -> start settle timer to avoid immediate snap bug
      if (!settleTimer){
        // play drop sound only once when first contacting the floor/another tile
        if (!dropSoundPending){
          playSound('drop');
          dropSoundPending = true;
        }
        settleTimer = setTimeout(()=>{ 
          settleTimer = null; 
          dropSoundPending = false;
          lockPiece(); 
        }, SETTLE_MS);
      }
    }
  }

  function restartTimer(){ 
    if (timer) clearInterval(timer); 
    timer = setInterval(step, tick); 
  }

  function startGame(){ 
    resetGrid(); 
    createBoard(); 
    draw(); 
    score = 0; 
    tick = TICK_START; 
    paused = false; 
    leaderboardPaused = false;
    current = null; 
    nextPiece = null; 
    justPlacedBlocks = []; // –û—á–∏—â–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ç–æ–ª—å–∫–æ —á—Ç–æ —É–ø–∞–≤—à–∏—Ö –±–ª–æ–∫–æ–≤
    newRecordShown = false;
    newRecordSoundPlayed = false; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –∑–≤—É–∫–∞ –Ω–æ–≤–æ–≥–æ —Ä–µ–∫–æ—Ä–¥–∞
    comboChain = 0; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ü–µ–ø–æ—á–∫—É –∫–æ–º–±–æ
    currentBest = best; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π –ª—É—á—à–∏–π —Å—á–µ—Ç –¥–ª—è —ç—Ç–æ–π –∏–≥—Ä—ã
    spawnNext(); 
    scoreEl.textContent='0'; 
    restartTimer(); 
    overlay.classList.remove('show'); 
    gameStarted = true;
    
    // Start gameplay
    if (ysdk && ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.start();
    }
    
    // Ensure audio context resumed if required and start BG music
    if (soundEnabled) {
      resumeAudioSystem();
    }
  }

  function gameOver(){ 
    clearInterval(timer); 
    current = null; 
    draw(); 
    playSound('gameover'); // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ –æ–∫–æ–Ω—á–∞–Ω–∏—è –∏–≥—Ä—ã
    stopBackgroundMusic(); // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –º—É–∑—ã–∫—É
    gameStarted = false;
    
    // Stop gameplay
    if (ysdk && ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.stop();
    }
    
    // Submit score to leaderboard
    if (score > 0) {
      submitScore(score).then(() => {
        // –ü–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ª—É—á—à–µ–≥–æ —Å—á–µ—Ç–∞
        bestEl.textContent = best;
      }).catch(err => {
        console.error('Error updating player score:', err);
      });
    }
    
    modal.innerHTML = `<div style="font-size:18px;font-weight:700;margin-bottom:8px">${t('game.gameOver')}</div><div class="small">${t('ui.score')}: ${score}</div><div style="height:10px"></div><div style="display:flex;gap:8px"><button id=again>${t('ui.playAgain')}</button><button id=close class='secondary'>${t('ui.close')}</button></div>`; 
    overlay.classList.add('show'); 
    document.getElementById('again').onclick = ()=>{ overlay.classList.remove('show'); startGame(); }; 
    document.getElementById('close').onclick = ()=>{ overlay.classList.remove('show'); } 
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è/—Å–∫—Ä—ã—Ç–∏—è –º–µ–Ω—é –ø–∞—É–∑—ã
  function togglePause() {
    paused = !paused;
    
    if (paused) {
      // Stop gameplay
      if (ysdk && ysdk.features.GameplayAPI) {
        ysdk.features.GameplayAPI.stop();
      }
      
      if (timer) clearInterval(timer);
      suspendAudioSystem();
      pauseMenuEl.classList.add('show');
    } else {
      pauseMenuEl.classList.remove('show');
      restartTimer();
      
      // Start gameplay
      if (ysdk && ysdk.features.GameplayAPI) {
        ysdk.features.GameplayAPI.start();
      }
      
      // resume audio system (background music) if allowed
      resumeAudioSystem();
    }
  }

  // input
  document.addEventListener('keydown', e=>{
    if (e.repeat) return;
    if (e.key === 'ArrowLeft'){ move(-1,0, true); draw(); e.preventDefault(); }
    else if (e.key === 'ArrowRight'){ move(1,0, true); draw(); e.preventDefault(); }
    else if (e.key === 'ArrowDown'){ move(0,1, true); draw(); e.preventDefault(); }
    else if (e.key === 'ArrowUp'){ rotate(); draw(); e.preventDefault(); }
    else if (e.code === 'Space'){ hardDrop(); e.preventDefault(); }
    else if (e.key.toLowerCase() === 'p' || e.key === 'Escape'){
      if (!leaderboardPaused) {
        togglePause();
      }
      e.preventDefault();
    }
  });

  // safe UI buttons
  (function(){ 
    const restartBtn = document.getElementById('restart'); 
    if (restartBtn) restartBtn.addEventListener('click', ()=>startGame()); 
  })();

  // Start button
  startButtonEl.addEventListener('click', () => {
    startScreenEl.style.display = 'none';
    startGame();
  });

  // Pause button
  pauseToggleEl.addEventListener('click', togglePause);

  // Pause menu buttons
  resumeButtonEl.addEventListener('click', () => {
    paused = false;
    pauseMenuEl.classList.remove('show');
    restartTimer();
    
    // Start gameplay
    if (ysdk && ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.start();
    }
    
    resumeAudioSystem();
  });

  restartButtonEl.addEventListener('click', () => {
    pauseMenuEl.classList.remove('show');
    startGame();
  });

  soundButtonEl.addEventListener('click', () => {
    toggleSound();
  });

  // Leaderboard button
  leaderboardButtonEl.addEventListener('click', () => {
    pauseMenuEl.classList.remove('show');
    
    // Pause the game for leaderboard without showing pause menu
    leaderboardPaused = true;
    
    // Stop gameplay
    if (ysdk && ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.stop();
    }
    
    // Pause game and audio
    if (timer) clearInterval(timer);
    suspendAudioSystem();
    
    loadLeaderboard();
    leaderboardOverlayEl.classList.add('show');
  });

  leaderboardCloseEl.addEventListener('click', () => {
    leaderboardOverlayEl.classList.remove('show');
    
    // Resume game after closing leaderboard
    leaderboardPaused = false;
    
    // Start gameplay
    if (ysdk && ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.start();
    }
    
    // Resume game and audio
    restartTimer();
    resumeAudioSystem();
  });

  // Leaderboard button in side panel
  document.getElementById('leaderboard').addEventListener('click', () => {
    // Pause the game for leaderboard without showing pause menu
    leaderboardPaused = true;
    
    // Stop gameplay
    if (ysdk && ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.stop();
    }
    
    // Pause game and audio
    if (timer) clearInterval(timer);
    suspendAudioSystem();
    
    loadLeaderboard();
    leaderboardOverlayEl.classList.add('show');
  });

  // Initialize Yandex SDK
  initYandexSDK().then(() => {
    console.log('Yandex SDK initialized successfully');
    // Set up game pause/resume events
    ysdk.on('game_api_pause', () => {
      if (!paused && gameStarted && !leaderboardPaused) {
        togglePause();
      }
    });
    
    ysdk.on('game_api_resume', () => {
      if (paused && gameStarted && !leaderboardPaused) {
        togglePause();
      }
    });
    
    // Start game loop for ads
    setInterval(() => {
      if (gameStarted && !paused && !leaderboardPaused) {
        showAd();
      }
    }, AD_INTERVAL);
  }).catch(err => {
    console.error('Failed to initialize Yandex SDK:', err);
    // Fallback to local storage if SDK not available
    startScreenEl.style.display = 'flex';
    
    // Try to detect language from browser
    currentLanguage = getCurrentLanguage();
    updateTranslations();
  });

  // initialization
  resetGrid(); 
  createBoard(); 
  nextPiece = makePiece(); 
  drawNext(); 

})();
</script>
</body>
</html>