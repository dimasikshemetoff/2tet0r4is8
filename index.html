<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>Плитки</title>

  <script src="/sdk.js"></script>
  <style>
    :root{
      --cell-size: 40px;
      --cols: 6;
      --rows: 12;
      --gap: 6px;
      --bg:#071026;
      --panel:#0f1720;
      --muted:#9aa4b2;
      --scale: 1;
    }
    *{box-sizing:border-box;font-family:Inter, system-ui, Arial, sans-serif;-webkit-tap-highlight-color:transparent}
    html,body{height:100%;overflow: hidden; margin:0;background-image:url('background.jpg');background-size:cover;background-position:center;color:#e6eef6;overflow-x:hidden;touch-action:manipulation}

    /* layout */
    .app{display:flex;gap:16px;align-items:flex-start;justify-content: center; max-width:1100px;margin:12px auto; height: 100vh; transform: scale(var(--scale)); transform-origin: top center;}
    .board-wrap{background:linear-gradient(180deg,rgba(9,16,37,0.9),rgba(7,16,32,0.9));padding:12px;border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,0.6);position:relative}

    /* board grid (visual guide) */
    .board{position:relative;display:grid;grid-template-columns:repeat(var(--cols),var(--cell-size));grid-template-rows:repeat(var(--rows),var(--cell-size));gap:var(--gap);background:rgba(6,18,37,0.9);padding:12px;border-radius:10px;min-height:calc(var(--rows) * var(--cell-size) + (var(--rows)-1)*var(--gap));overflow:hidden}

    /* static cell background to keep grid look */
    .cell-bg{width:var(--cell-size);height:var(--cell-size);border-radius:8px;background:rgba(255,255,255,0.02);box-shadow:inset 0 -3px rgba(0,0,0,0.2)}

    /* floating tile elements for animation */
    .tile-el{position:absolute;width:var(--cell-size);height:var(--cell-size);display:flex;align-items:center;justify-content:center;border-radius:8px;font-weight:800;transition:transform 220ms cubic-bezier(.2,.9,.2,1), top 220ms cubic-bezier(.2,.9,.2,1), left 220ms cubic-bezier(.2,.9,.2,1);box-shadow:0 6px 18px rgba(2,6,23,0.6);pointer-events:none}
    .tile-el .label{transform:translateY(1px)}

    /* merge animation */
    .merge-anim{animation:mergePop 320ms ease forwards}
    @keyframes mergePop{0%{transform:scale(1)}40%{transform:scale(1.6)}100%{transform:scale(1)}}

    /* particle (star) */
    .particle{position:absolute;width:10px;height:10px;border-radius:50%;background:gold;box-shadow:0 0 8px gold, 0 0 20px rgba(255,200,50,0.6);pointer-events:none;opacity:0}
    @keyframes starFly{
      0%{opacity:1;transform:translate(0,0) scale(1)}
      60%{opacity:1}
      100%{opacity:0;transform:translate(var(--dx),var(--dy)) scale(0.6)}
    }

    /* praise text */
    .praise{position:absolute;font-weight:800;color:#fff;text-shadow:0 4px 16px rgba(0,0,0,0.6);pointer-events:none;opacity:0;transform:translateY(0);transition:transform 480ms cubic-bezier(.2,.9,.2,1),opacity 480ms}
    .praise.show{opacity:1;transform:translateY(-40px)}

    /* combo text */
    .combo{position:absolute;font-weight:900;color:#ffd86b;text-shadow:0 6px 18px rgba(0,0,0,0.6);pointer-events:none;opacity:0;transform:translateY(0);transition:transform 420ms cubic-bezier(.2,.9,.2,1),opacity 420ms;font-size:20px}
    .combo.show{opacity:1;transform:translateY(-36px) scale(1.05)}

    /* new record notification */
    .new-record{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);font-weight:900;color:#ffd86b;font-size:28px;text-shadow:0 6px 18px rgba(0,0,0,0.6);pointer-events:none;opacity:0;z-index:50;transition:transform 480ms cubic-bezier(.2,.9,.2,1),opacity 480ms}
    .new-record.show{opacity:1;transform:translate(-50%, -50%) scale(1.1)}

    /* tile colors (use data-val attribute) */
    .tile-el[data-val="2"]{background:linear-gradient(180deg,#f1efe9,#efe8d6);color:#2b2b2b}
    .tile-el[data-val="4"]{background:linear-gradient(180deg,#f3e7d7,#f0d8b7);color:#2b2b2b}
    .tile-el[data-val="8"]{background:linear-gradient(180deg,#f7cf95,#f0b46b);color:#111}
    .tile-el[data-val="16"]{background:linear-gradient(180deg,#f09e5b,#e67a3b);color:#fff}
    .tile-el[data-val="32"]{background:linear-gradient(180deg,#e86e4b,#c94c2f);color:#fff}
    .tile-el[data-val="64"]{background:linear-gradient(180deg,#d44c8a,#b7306f);color:#fff}
    .tile-el[data-val="128"]{background:linear-gradient(180deg,#6db7f7,#3b8fe8);color:#fff}
    .tile-el[data-val="256"]{background:linear-gradient(180deg,#74d7b2,#2db386);color:#042018}
    .tile-el[data-val="512"]{background:linear-gradient(180deg,#a293ff,#7a5dff);color:#fff}
    .tile-el[data-val="1024"]{background:linear-gradient(180deg,#ffd86b,#ffb84f);color:#111}
    .tile-el[data-val="2048"]{background:linear-gradient(180deg,#ffe0a9,#ffd676);color:#111}

    /* side panel */
    .side{display:flex;flex-direction:column;gap:12px;width:260px}
    .panel{background:var(--panel);padding:12px;border-radius:8px;box-shadow:inset 0 -4px rgba(0,0,0,.25)}
    .title{font-size:18px;font-weight:700;margin-bottom:6px}
    .stat{font-size:13px;color:var(--muted)}
    button{padding:10px;border-radius:8px;border:0;background:#0f1726;color:#dfe9f8;cursor:pointer}
    button.secondary{background:#121827;color:var(--muted)}
    .next-piece{display:grid;grid-template-columns:repeat(4,40px);grid-auto-rows:40px;gap:6px;justify-content:center}
    .footer{font-size:13px;color:var(--muted);margin-top:8px}
    .controls-list{font-size:13px;color:var(--muted);display:block;line-height:1.6}
    .hint{font-size:13px;color:#bcd0ff}
    .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:100}
    .overlay.show{display:flex}
    .modal{background:#0c1320;padding:24px;border-radius:12px;box-shadow:0 10px 40px rgba(0,0,0,0.6);max-width:90vw;max-height:90vh;overflow:auto}
    .small{font-size:12px;color:var(--muted)}
    
    /* Sound toggle button */
    .sound-toggle {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: rgba(15, 23, 38, 0.8);
      border: none;
      color: #dfe9f8;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      z-index: 10;
      transition: background 0.2s;
    }
    .sound-toggle:hover {
      background: rgba(15, 23, 38, 1);
    }
    .sound-toggle.muted {
      opacity: 0.5;
    }
    
    /* Pause button */
    .pause-toggle {
      position: absolute;
      top: 12px;
      right: 54px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: rgba(15, 23, 38, 0.8);
      border: none;
      color: #dfe9f8;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      z-index: 10;
      transition: background 0.2s;
    }
    .pause-toggle:hover {
      background: rgba(15, 23, 38, 1);
    }
    
    /* Start screen */
    .start-screen {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(5, 6, 10, 0.9);
      z-index: 200;
    }
    .start-modal {
      background: #0c1320;
      padding: 32px;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      max-width: 400px;
      text-align: center;
    }
    .start-title {
      font-size: 32px;
      font-weight: 900;
      margin-bottom: 20px;
      background: linear-gradient(180deg, #ffd86b, #ffb84f);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .start-description {
      font-size: 16px;
      color: #e6eef6;
      margin-bottom: 24px;
      line-height: 1.5;
    }
    .start-button {
      opacity: 0;
      padding: 12px 24px;
      font-size: 18px;
      font-weight: 700;
      background: linear-gradient(180deg, #3b8fe8, #2a6ac4);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .start-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(59, 143, 232, 0.4);
    }
    
    /* Pause menu */
    .pause-menu {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(5, 6, 10, 0.9);
      z-index: 150;
    }
    .pause-menu.show {
      display: flex;
    }
    .pause-modal {
      background: #0c1320;
      padding: 32px;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      max-width: 400px;
      text-align: center;
    }
    .pause-title {
      font-size: 28px;
      font-weight: 900;
      margin-bottom: 20px;
      color: #e6eef6;
    }
    .pause-buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .pause-button {
      padding: 12px 24px;
      font-size: 16px;
      font-weight: 700;
      background: #0f1726;
      color: #dfe9f8;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s, background 0.2s;
    }
    .pause-button:hover {
      transform: translateY(-2px);
      background: #1a2332;
    }
    .pause-button.primary {
      background: linear-gradient(180deg, #3b8fe8, #2a6ac4);
      color: white;
    }
    .pause-button.primary:hover {
      background: linear-gradient(180deg, #4a9cf8, #3979d4);
    }
    
    /* Leaderboard styles */
    .leaderboard {
      background: #0c1320;
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }
    .leaderboard-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 16px;
      color: #e6eef6;
      text-align: center;
    }
    .leaderboard-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .leaderboard-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 12px;
      background: rgba(15, 23, 38, 0.5);
      border-radius: 8px;
    }
    .leaderboard-item.current-player {
      background: rgba(59, 143, 232, 0.3);
      border: 1px solid rgba(59, 143, 232, 0.5);
    }
    .leaderboard-rank {
      font-weight: 700;
      color: #ffd86b;
      width: 30px;
    }
    .leaderboard-name {
      flex-grow: 1;
      margin: 0 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .leaderboard-score {
      font-weight: 700;
      color: #e6eef6;
    }
    .leaderboard-close {
      margin-top: 16px;
      width: 100%;
    }
    .leaderboard-loading {
      text-align: center;
      padding: 20px;
      color: var(--muted);
    }
    .leaderboard-empty {
      text-align: center;
      padding: 20px;
      color: var(--muted);
    }
    .leaderboard-separator {
      text-align: center;
      padding: 10px;
      color: var(--muted);
      font-size: 14px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      margin-top: 10px;
    }
    
    /* Responsive adjustments */
    @media (max-width: 620px), (max-height: 615px) {
      .app {
        margin: 0;
        gap: 8px;
      }
      .side {
        width: 200px;
      }
      .panel {
        padding: 8px;
      }
      .title {
        font-size: 16px;
      }
      .stat {
        font-size: 12px;
      }
      button {
        padding: 8px;
        font-size: 14px;
      }
      .next-piece {
        grid-template-columns: repeat(4, 30px);
        grid-auto-rows: 30px;
        gap: 4px;
      }
    }
  </style>
</head>
<body>
  <!-- Start Screen -->
  <div class="start-screen" id="startScreen">
    <div class="start-modal">
      <div class="start-description" data-i18n="game.description">
        Соединяйте одинаковые плитки, чтобы создавать большие значения. 
        Управляйте фигурами и создавайте комбо для получения дополнительных очков!
      </div>
      <button class="start-button" id="startButton" data-i18n="game.start">Начать игру</button>
    </div>
  </div>

  <!-- Pause Menu -->
  <div class="pause-menu" id="pauseMenu">
    <div class="pause-modal">
      <div class="pause-title" data-i18n="pause.title">ПАУЗА</div>
      <div class="pause-buttons">
        <button class="pause-button primary" id="resumeButton" data-i18n="pause.resume">Продолжить</button>
        <button class="pause-button" id="restartButton" data-i18n="pause.newGame">Новая игра</button>
        <button class="pause-button" id="soundButton" data-i18n="pause.sound">Звук: Вкл</button>
        <button class="pause-button" id="leaderboardButton" data-i18n="pause.leaderboard">Таблица лидеров</button>
      </div>
    </div>
  </div>

  <!-- Leaderboard Modal -->
  <div class="overlay" id="leaderboardOverlay">
    <div class="leaderboard">
      <div class="leaderboard-title" data-i18n="leaderboard.title">Таблица лидеров</div>
      <div id="leaderboardContent" class="leaderboard-list">
        <div class="leaderboard-loading" data-i18n="leaderboard.loading">Загрузка...</div>
      </div>
      <button class="pause-button leaderboard-close" id="leaderboardClose" data-i18n="leaderboard.close">Закрыть</button>
    </div>
  </div>

  <div class="app">
    <div class="side">
      <div class="panel">
        <div class="stat"><span data-i18n="ui.score">Счёт</span>: <span id="score">0</span></div>
        <div class="stat"><span data-i18n="ui.best">Рекорд</span>: <span id="best">0</span></div>
        <div style="height:8px"></div>
        <button id="restart" data-i18n="ui.newGame">Новая игра</button>
        <button id="leaderboard" data-i18n="ui.leaderboard">Таблица лидеров</button>
      </div>
      <div class="panel">
        <div class="small" data-i18n="ui.nextPiece">Следующая фигура:</div>
        <div class="next-piece" id="nextPiece"></div>
      </div>
    </div>

    <div class="board-wrap">
      <button class="sound-toggle" id="soundToggle" title="Включить/выключить звук">🔊</button>
      <button class="pause-toggle" id="pauseToggle" title="Пауза">⏸️</button>
      <div class="board" id="board" aria-label="Игровое поле">
        <div class="new-record" id="newRecord" data-i18n="game.newRecord">НОВЫЙ РЕКОРД!</div>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay"><div class="modal" id="modal"></div></div>

<script>
(() => {
  // CONFIG
  const COLS = 6;
  const ROWS = 12;
  const TICK_START = 700;
  const MIN_TICK = 100;
  const SETTLE_MS = 140; // small delay before locking to avoid instant snap bug
  const AD_INTERVAL = 300000; // 5 minutes in milliseconds

  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const nextEl = document.getElementById('nextPiece');
  const overlay = document.getElementById('overlay');
  const modal = document.getElementById('modal');
  const newRecordEl = document.getElementById('newRecord');
  const appEl = document.querySelector('.app');
  const soundToggleEl = document.getElementById('soundToggle');
  const pauseToggleEl = document.getElementById('pauseToggle');
  const startScreenEl = document.getElementById('startScreen');
  const startButtonEl = document.getElementById('startButton');
  const pauseMenuEl = document.getElementById('pauseMenu');
  const resumeButtonEl = document.getElementById('resumeButton');
  const restartButtonEl = document.getElementById('restartButton');
  const soundButtonEl = document.getElementById('soundButton');
  const leaderboardButtonEl = document.getElementById('leaderboardButton');
  const leaderboardOverlayEl = document.getElementById('leaderboardOverlay');
  const leaderboardContentEl = document.getElementById('leaderboardContent');
  const leaderboardCloseEl = document.getElementById('leaderboardClose');

  let grid = [];
  let current = null;
  let nextPiece = null;
  let tick = TICK_START;
  let timer = null;
  let score = 0;
  let best = Number(localStorage.getItem('tetris2048_best') || 0);
  let paused = false;
  let settleTimer = null;
  let tileLayer = null; // will be created and appended inside createBoard
  let newRecordShown = false; // flag to prevent showing new record multiple times
  let newRecordSoundPlayed = false; // flag to prevent playing new record sound multiple times
  let comboChain = 0; // track consecutive merges
  let justPlacedBlocks = []; // track blocks that were just placed
  let gameStarted = false; // flag to track if game has started
  let currentBest = 0; // track current best score in this session
  let lastAdTime = 0; // track when last ad was shown
  let playerName = "Игрок"; // default player name
  let isAuthorized = false; // track if player is authorized
  let leaderboardData = []; // store leaderboard data
  let currentLanguage = 'ru'; // язык по умолчанию
  let leaderboardPaused = false; // track if game is paused for leaderboard

  // flag to prevent multiple drop sounds from repeated settle attempts
  let dropSoundPending = false;

  // Yandex Games SDK variables
  let ysdk = null;
  let player = null;

  // Internationalization
  const translations = {
    ru: {
      game: {
        description: "Соединяйте одинаковые плитки, чтобы создавать большие значения. Управляйте фигурами и создавайте комбо для получения дополнительных очков!",
        start: "Начать игру",
        newRecord: "НОВЫЙ РЕКОРД!",
        gameOver: "Конец игры"
      },
      pause: {
        title: "ПАУЗА",
        resume: "Продолжить",
        newGame: "Новая игра",
        sound: "Звук: Вкл",
        soundoff: "Звук: Выкл",
        leaderboard: "Таблица лидеров"
      },
      ui: {
        score: "Счёт",
        best: "Рекорд",
        newGame: "Новая игра",
        leaderboard: "Таблица лидеров",
        nextPiece: "Следующая фигура:",
        playAgain: "Играть ещё",
        close: "Закрыть"
      },
      leaderboard: {
        title: "Таблица лидеров",
        loading: "Загрузка...",
        close: "Закрыть",
        empty: "Место не занято",
        yourPlace: "Ваше место"
      },
      praise: {
        bombastic: "БОМБЕЗНО!",
        amazing: "Потрясающе!",
        excellent: "Великолепно!",
        great: "Отлично!",
        good: "Хорошо!",
        super: "Супер!",
        comboMaster: "КОМБО-МАСТЕР!",
        classicCombo: "Классический комбо!"
      }
    },
    en: {
      game: {
        description: "Connect identical tiles to create larger values. Control shapes and create combos for extra points!",
        start: "Start Game",
        newRecord: "NEW RECORD!",
        gameOver: "Game Over"
      },
      pause: {
        title: "PAUSE",
        resume: "Resume",
        newGame: "New Game",
        sound: "Sound: On",
        soundoff: "Sound: Off",
        leaderboard: "Leaderboard"
      },
      ui: {
        score: "Score",
        best: "Best",
        newGame: "New Game",
        leaderboard: "Leaderboard",
        nextPiece: "Next piece:",
        playAgain: "Play Again",
        close: "Close"
      },
      leaderboard: {
        title: "Leaderboard",
        loading: "Loading...",
        close: "Close",
        empty: "Position not taken",
        yourPlace: "Your position"
      },
      praise: {
        bombastic: "BOMBASTIC!",
        amazing: "Amazing!",
        excellent: "Excellent!",
        great: "Great!",
        good: "Good!",
        super: "Super!",
        comboMaster: "COMBO MASTER!",
        classicCombo: "Classic combo!"
      }
    }
  };

  // Get current language
  function getCurrentLanguage() {
    // Try to get language from Yandex SDK if available
    if (ysdk && ysdk.environment && ysdk.environment.i18n) {
      return ysdk.environment.i18n.lang;
    }
    
    // Fallback to browser language
    const browserLang = navigator.language || navigator.userLanguage;
    if (browserLang.startsWith('en')) return 'en';
    if (browserLang.startsWith('ru')) return 'ru';
    
    // Default to Russian
    return 'ru';
  }

  // Translate text
  function t(key) {
    const keys = key.split('.');
    let value = translations[currentLanguage];
    
    for (const k of keys) {
      if (value && value[k]) {
        value = value[k];
      } else {
        // Fallback to Russian if translation not found
        value = translations.ru;
        for (const k of keys) {
          if (value && value[k]) {
            value = value[k];
          } else {
            return key; // Return key if translation not found
          }
        }
        break;
      }
    }
    
    return value;
  }

  // Update all UI elements with translations
  function updateTranslations() {
    document.querySelectorAll('[data-i18n]').forEach(element => {
      const key = element.getAttribute('data-i18n');
      element.textContent = t(key);
    });
    
    
    
    // Update sound button text
    soundButtonEl.textContent = (soundEnabled ? t('pause.sound') : t('pause.soundoff'));
    
    // Update tooltips
    soundToggleEl.title = t('ui.soundToggle');
    pauseToggleEl.title = t('ui.pause');
  }

  bestEl.textContent = best;
  currentBest = best;

  // Initialize Yandex Games SDK
  function initYandexSDK() {
    return new Promise((resolve, reject) => {
      if (typeof YaGames !== 'undefined') {
        YaGames.init({
          scope: 'public_data'
        }).then(_ysdk => {
          ysdk = _ysdk;
          console.log('Yandex SDK initialized');
          
          // ОПРЕДЕЛЕНИЕ ЯЗЫКА
          currentLanguage = getCurrentLanguage();
          console.log('Language detected:', currentLanguage);
          
          // Update translations after language detection
          updateTranslations();
          
          // Get player info
          player = ysdk.getPlayer({
            scopes: 'public_data'
          }).then(_player => {
            player = _player;
            playerName = player.getName() || (currentLanguage === 'en' ? "Player" : "Игрок");
            isAuthorized = player.isAuthorized();
            console.log('Player info loaded:', playerName, isAuthorized);
            
            // Get environment info
            const env = ysdk.environment;
            console.log('Environment:', env);
            
            // Call ready when all resources are loaded
            if (ysdk.features.LoadingAPI) {
              ysdk.features.LoadingAPI.ready();
              document.getElementById('startButton').style.opacity = 1;
            }
            
            resolve();
          }).catch(err => {
            console.error('Error getting player info:', err);
            
            // Get environment info even if player info fails
            const env = ysdk.environment;
            console.log('Environment:', env);
            
            // Call ready when all resources are loaded
            if (ysdk.features.LoadingAPI) {
              ysdk.features.LoadingAPI.ready();
            }
            
            resolve();
          });
        }).catch(err => {
          console.error('Error initializing Yandex SDK:', err);
          reject(err);
        });
      } else {
        console.error('Yandex SDK not available');
        reject(new Error('Yandex SDK not available'));
      }
    });
  }

  // Show ad
  function showAd() {
    if (!ysdk) return;
    
    const now = Date.now();
    if (now - lastAdTime < AD_INTERVAL) return; // Don't show ad if not enough time has passed
    
    lastAdTime = now;
    
    // Stop gameplay
    if (ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.stop();
    }
    
    // Pause game and audio
    if (timer) clearInterval(timer);
    suspendAudioSystem();
    
    // Show fullscreen ad
    ysdk.adv.showFullscreenAdv({
      callbacks: {
        onClose: () => {
          console.log('Ad closed');
          // Resume game and audio
          if (!paused && gameStarted) {
            // Start gameplay
            if (ysdk.features.GameplayAPI) {
              ysdk.features.GameplayAPI.start();
            }
            
            restartTimer();
            resumeAudioSystem();
          }
        },
        onError: (err) => {
          console.error('Ad error:', err);
          // Resume game and audio even if ad fails
          if (!paused && gameStarted) {
            // Start gameplay
            if (ysdk.features.GameplayAPI) {
              ysdk.features.GameplayAPI.start();
            }
            
            restartTimer();
            resumeAudioSystem();
          }
        }
      }
    });
  }

  // Show rewarded ad
  function showRewardedAd(callback) {
    if (!ysdk) {
      if (callback) callback(false);
      return;
    }
    
    // Stop gameplay
    if (ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.stop();
    }
    
    // Pause game and audio
    if (timer) clearInterval(timer);
    suspendAudioSystem();
    
    // Show rewarded ad
    ysdk.adv.showRewardedVideo({
      callbacks: {
        onOpen: () => console.log('Rewarded ad opened'),
        onRewarded: () => {
          console.log('Rewarded ad completed');
          if (callback) callback(true);
        },
        onClose: () => {
          console.log('Rewarded ad closed');
          // Resume game and audio
          if (!paused && gameStarted) {
            // Start gameplay
            if (ysdk.features.GameplayAPI) {
              ysdk.features.GameplayAPI.start();
            }
            
            restartTimer();
            resumeAudioSystem();
          }
          if (callback) callback(false);
        },
        onError: (err) => {
          console.error('Rewarded ad error:', err);
          // Resume game and audio even if ad fails
          if (!paused && gameStarted) {
            // Start gameplay
            if (ysdk.features.GameplayAPI) {
              ysdk.features.GameplayAPI.start();
            }
            
            restartTimer();
            resumeAudioSystem();
          }
          if (callback) callback(false);
        }
      }
    });
  }

  // Load leaderboard
  function loadLeaderboard() {
    if (!ysdk || !ysdk.leaderboards) {
      showEmptyLeaderboard();
      return Promise.resolve();
    }
    
    // Проверяем доступность методов таблицы лидеров
    return ysdk.isAvailableMethod('leaderboards.getEntries').then(available => {
      if (!available) {
        console.log('Leaderboards methods not available for this user');
        showEmptyLeaderboard();
        return;
      }
      
      // Get leaderboard
      return Promise.all([
        ysdk.leaderboards.getEntries('leaders', {
          quantityTop: 10,
          includeUser: false
        }),
        ysdk.leaderboards.getPlayerEntry('leaders').catch(err => {
          if (err.code === 'LEADERBOARD_PLAYER_NOT_PRESENT') {
            return null;
          }
          throw err;
        })
      ]).then(([topEntries, playerEntry]) => {
        leaderboardData = topEntries.entries;
        displayLeaderboard(leaderboardData, playerEntry ? playerEntry.rank : null);
      }).catch(err => {
        console.error('Error getting leaderboard:', err);
        showEmptyLeaderboard();
      });
    }).catch(err => {
      console.log('Error checking leaderboard availability:', err);
      showEmptyLeaderboard();
    });
  }

  // Show empty leaderboard if SDK not available
  function showEmptyLeaderboard() {
    displayLeaderboard([]);
  }

  // Display leaderboard
  function displayLeaderboard(data, userRank) {
    if (!data || data.length === 0) {
      let html = '';
      for (let i = 1; i <= 10; i++) {
        html += `
          <div class="leaderboard-item">
            <div class="leaderboard-rank">${i}</div>
            <div class="leaderboard-name">${t('leaderboard.empty')}</div>
            <div class="leaderboard-score">-</div>
          </div>
        `;
      }
      
      if (best > 0) {
        html += `
          <div class="leaderboard-separator">${t('leaderboard.yourPlace')}</div>
          <div class="leaderboard-item current-player">
            <div class="leaderboard-rank">-</div>
            <div class="leaderboard-name">${playerName}</div>
            <div class="leaderboard-score">${best}</div>
          </div>
        `;
      }
      
      leaderboardContentEl.innerHTML = html;
      return;
    }
    
    let html = '';
    let playerInList = false;
    
    // Add existing entries
    for (let i = 0; i < Math.min(10, data.length); i++) {
      const entry = data[i];
      const isCurrentPlayer = entry.player && entry.player.uniqueID === (player ? player.uniqueID : null);
      if (isCurrentPlayer) playerInList = true;
      
      html += `
        <div class="leaderboard-item ${isCurrentPlayer ? 'current-player' : ''}">
          <div class="leaderboard-rank">${entry.rank}</div>
          <div class="leaderboard-name">${entry.player ? entry.player.publicName : (currentLanguage === 'en' ? 'Anonymous' : 'Аноним')}</div>
          <div class="leaderboard-score">${entry.score}</div>
        </div>
      `;
    }
    
    // Fill remaining slots with empty positions
    for (let i = data.length; i < 10; i++) {
      html += `
        <div class="leaderboard-item">
          <div class="leaderboard-rank">${i + 1}</div>
          <div class="leaderboard-name">${t('leaderboard.empty')}</div>
          <div class="leaderboard-score">-</div>
        </div>
      `;
    }
    
    // Add current player if not in list and has a score
    if (!playerInList && best > 0) {
      html += `
        <div class="leaderboard-separator">${t('leaderboard.yourPlace')}</div>
        <div class="leaderboard-item current-player">
          <div class="leaderboard-rank">${userRank ? userRank : '-'}</div>
          <div class="leaderboard-name">${playerName}</div>
          <div class="leaderboard-score">${best}</div>
        </div>
      `;
    }
    
    leaderboardContentEl.innerHTML = html;
  }

  // Submit score to leaderboard
  function submitScore(score) {
    if (!ysdk || !ysdk.leaderboards || score <= 0) {
      console.log('Leaderboards not available or invalid score');
      return Promise.resolve();
    }
    
    // Всегда обновляем локальный рекорд
    if (score > best) {
      best = score;
      bestEl.textContent = best;
      localStorage.setItem('tetris2048_best', best);
      
      if (player) {
        player.setData({ bestScore: best });
      }
      
      if (!newRecordSoundPlayed) {
        playSound('newrecord');
        newRecordSoundPlayed = true;
      }
    }
    
    // Проверяем, доступен ли метод для установки счета
    return ysdk.isAvailableMethod('leaderboards.setScore').then(available => {
      if (!available) {
        console.log('Leaderboard setScore method not available for this user');
        return;
      }
      
      // Сначала пробуем получить текущую запись игрока
      return ysdk.leaderboards.getPlayerEntry('leaders')
        .then(currentEntry => {
          // Если запись существует и текущий счет лучше - обновляем
          if (!currentEntry || score >= currentEntry.score) {
            return ysdk.leaderboards.setScore('leaders', score);
          }
        })
        .then(() => {
          console.log('Score successfully updated in leaderboard:', score);
        })
        .catch(err => {
          // Обрабатываем ошибку, когда игрок отсутствует в таблице лидеров
          if (err.code === 'LEADERBOARD_PLAYER_NOT_PRESENT') {
            console.log('Player not present in leaderboard, adding player...');
            // Если игрок отсутствует, просто устанавливаем счет
            return ysdk.leaderboards.setScore('leaders', score)
              .then(() => {
                console.log('Player added to leaderboard with score:', score);
              });
          } else if (err.code === 'LEADERBOARD_TOO_MANY_REQUESTS') {
            console.log('Too many requests, retrying in 1 second');
            setTimeout(() => submitScore(score), 1000);
          } else if (err.code === 'NETWORK_ERROR') {
            console.log('Network error, retrying in 2 seconds');
            setTimeout(() => submitScore(score), 2000);
          } else {
            console.error('Error updating leaderboard score:', err);
          }
        });
    }).catch(err => {
      console.log('Error checking leaderboard availability:', err);
    });
  }

  // Responsive scaling function
  function updateScale() {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    const normalWidth = 620;
    const normalHeight = 615;
    const largeWidth = 1000;
    const largeHeight = 650;
    const minSize = 320;
    
    // Calculate scale based on window size
    let scale;
    
    if (windowWidth < normalWidth || windowHeight < normalHeight) {
      // Window is smaller than normal dimensions - decrease scale
      const scaleX = Math.max(minSize / normalWidth, windowWidth / normalWidth);
      const scaleY = Math.max(minSize / normalHeight, windowHeight / normalHeight);
      scale = Math.min(scaleX, scaleY);
    } else if (windowWidth >= largeWidth && windowHeight >= largeHeight) {
      // Window is larger than large dimensions - increase scale to fill the screen
      const scaleX = windowWidth / largeWidth;
      const scaleY = windowHeight / largeHeight;
      scale = Math.min(scaleX, scaleY);
    } else {
      // Window is between normal and large dimensions - keep scale at 1
      scale = 1;
    }
    
    // Apply scale to CSS variable
    document.documentElement.style.setProperty('--scale', scale);
  }

  // Initial scale calculation
  updateScale();
  
  // Update scale on window resize
  window.addEventListener('resize', updateScale);

  // WebAudio API Sound System
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  const sounds = {};
  let soundEnabled = true;
  let bgMusicSource = null;
  let bgMusicGainNode = null;
  
  // Загрузка звуков
  function loadSounds() {
    // Создаем пустые функции для звуков, чтобы избежать ошибок до их загрузки
    sounds.move = () => {};
    sounds.rotate = () => {};
    sounds.drop = () => {};
    sounds.merge = () => {};
    sounds.combo = () => {};
    sounds.megacombo = () => {};
    sounds.gameover = () => {};
    sounds.newrecord = () => {};
    sounds.background = () => {};

    // Загружаем звуки асинхронно
    loadSound('move.mp3').then(sound => { if (sound) sounds.move = sound; });
    loadSound('rotate.mp3').then(sound => { if (sound) sounds.rotate = sound; });
    loadSound('drop.mp3').then(sound => { if (sound) sounds.drop = sound; });
    loadSound('merge.mp3').then(sound => { if (sound) sounds.merge = sound; });
    loadSound('combo.mp3').then(sound => { if (sound) sounds.combo = sound; });
    loadSound('megacombo.mp3').then(sound => { if (sound) sounds.megacombo = sound; });
    loadSound('gameover.mp3').then(sound => { if (sound) sounds.gameover = sound; });
    loadSound('newrecord.mp3').then(sound => { if (sound) sounds.newrecord = sound; });
    // background handled separately because we use looping bufferSource
    // but keep a loaded buffer as convenience
    loadSoundBuffer('background.mp3').then(buffer => { if (buffer) sounds.backgroundBuffer = buffer; });
  }
  
  // Функция для загрузки звука и возврата функции-воспроизведения
  function loadSound(url) {
    return fetch(url)
      .then(response => {
        if (!response.ok) throw new Error('not found');
        return response.arrayBuffer();
      })
      .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
      .then(audioBuffer => {
        return () => {
          if (!soundEnabled) return;
          // don't attempt to start audioContext if suspended
          if (audioContext.state === 'suspended') return;
          
          const source = audioContext.createBufferSource();
          source.buffer = audioBuffer;
          
          const gainNode = audioContext.createGain();
          gainNode.gain.value = 0.7;
          
          source.connect(gainNode);
          gainNode.connect(audioContext.destination);
          source.start();
        };
      })
      .catch(error => {
        console.warn('Error loading sound:', url, error);
        return null;
      });
  }

  // load background buffer for looped playback
  function loadSoundBuffer(url){
    return fetch(url)
      .then(response => {
        if (!response.ok) throw new Error('not found');
        return response.arrayBuffer();
      })
      .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
      .catch(err => { console.warn('bg load err', err); return null; });
  }

  // Воспроизведение звука
  function playSound(soundName) {
    if (!soundEnabled) return;
    if (audioContext.state === 'suspended') return;
    if (sounds[soundName]) {
      try { sounds[soundName](); } catch(e){ /* ignore */ }
    }
  }
  
  // Воспроизведение фоновой музыки в цикле (с использованием ранее загруженного буфера)
  function playBackgroundMusic() {
    if (!soundEnabled) return;
    if (audioContext.state === 'suspended') return;
    stopBackgroundMusic();
    if (!sounds.backgroundBuffer) {
      // если буфер ещё не загружен, попытаться запустить fetch-процесс:
      loadSoundBuffer('background.mp3').then(buffer => {
        if (!buffer) return;
        sounds.backgroundBuffer = buffer;
        _startBgFromBuffer(buffer);
      }).catch(()=>{});
      return;
    }
    _startBgFromBuffer(sounds.backgroundBuffer);
  }
  function _startBgFromBuffer(buffer){
    try {
      bgMusicSource = audioContext.createBufferSource();
      bgMusicSource.buffer = buffer;
      bgMusicSource.loop = true;
      bgMusicGainNode = audioContext.createGain();
      bgMusicGainNode.gain.value = 0.3;
      bgMusicSource.connect(bgMusicGainNode);
      bgMusicGainNode.connect(audioContext.destination);
      bgMusicSource.start(0);
    } catch(e){
      console.warn('bg start error', e);
    }
  }
  
  // Остановка фоновой музыки
  function stopBackgroundMusic() {
    if (bgMusicSource) {
      try { bgMusicSource.stop(); } catch(e) {}
      bgMusicSource = null;
    }
    if (bgMusicGainNode) {
      try { bgMusicGainNode.disconnect(); } catch(e) {}
      bgMusicGainNode = null;
    }
  }
  
  // Переключение звука (UI-кнопка)
  function toggleSound() {
    soundEnabled = !soundEnabled;
    soundToggleEl.textContent = soundEnabled ? '🔊' : '🔇';
    soundToggleEl.classList.toggle('muted', !soundEnabled);
    soundButtonEl.textContent =  (soundEnabled ? t('pause.sound') : t('pause.soundoff'));
    
    if (soundEnabled) {
      // если аудио-контекст был suspended из-за паузы, не принудительно resume здесь
      if (audioContext.state === 'suspended') {
        audioContext.resume().then(()=>{
          if (!paused && gameStarted) playBackgroundMusic();
        });
      } else {
        if (!paused && gameStarted) playBackgroundMusic();
      }
    } else {
      stopBackgroundMusic();
    }
  }
  
  // Остановить всё аудио (используется при паузе)
  function suspendAudioSystem() {
    stopBackgroundMusic();
    // suspend audio context to halt any sources
    if (audioContext && audioContext.state === 'running') {
      audioContext.suspend().catch(()=>{});
    }
  }
  // Восстановить аудио после паузы
  function resumeAudioSystem() {
    if (audioContext && audioContext.state === 'suspended') {
      audioContext.resume().then(()=>{ if (soundEnabled && gameStarted) playBackgroundMusic(); }).catch(()=>{});
    } else {
      if (soundEnabled && gameStarted) playBackgroundMusic();
    }
  }

  // Обработчик кнопки переключения звука
  soundToggleEl.addEventListener('click', toggleSound);
  
  // Инициализация звуковой системы
  loadSounds();

  // shapes
  const SHAPES = {
    I: [[0,1],[1,1],[2,1],[3,1]],
    O: [[0,0],[1,0],[0,1],[1,1]],
    T: [[0,1],[1,1],[2,1],[1,0]],
    L: [[0,0],[0,1],[0,2],[1,2]],
    J: [[1,0],[1,1],[1,2],[0,2]],
    S: [[0,1],[1,1],[1,0],[2,0]],
    Z: [[0,0],[1,0],[1,1],[2,1]]
  };
  const SHAPE_KEYS = Object.keys(SHAPES);

  // DOM helpers: grid background cells
  function createBoard(){
    boardEl.style.setProperty('--cols', COLS);
    boardEl.style.setProperty('--rows', ROWS);
    boardEl.innerHTML = `<div class="new-record" id="newRecord">${t('game.newRecord')}</div>`;
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const bg = document.createElement('div');
        bg.className = 'cell-bg';
        bg.dataset.r = r; bg.dataset.c = c;
        boardEl.appendChild(bg);
      }
    }
    // create/attach tileLayer for absolute positioned animated tiles
    if (!tileLayer){
      tileLayer = document.createElement('div');
      tileLayer.style.position = 'absolute';
      tileLayer.style.inset = '12px';
      tileLayer.style.pointerEvents = 'none';
    }
    tileLayer.innerHTML = '';
    boardEl.appendChild(tileLayer);
  }

  function resetGrid(){ grid = Array.from({length:ROWS},()=>Array(COLS).fill(0)); }

  function randInitialValue(){ const r = Math.random(); if (r<0.7) return 2; if (r<0.95) return 4; return 8; }

  function makePiece(shapeKey=null){
    const key = shapeKey || SHAPE_KEYS[Math.floor(Math.random()*SHAPE_KEYS.length)];
    const blocks = SHAPES[key].map(p=>({x:p[0], y:p[1], v: randInitialValue()}));
    const minX = Math.min(...blocks.map(b=>b.x));
    const maxX = Math.max(...blocks.map(b=>b.x));
    const width = maxX-minX+1;
    const offsetX = Math.floor((COLS-width)/2) - minX;
    const offsetY = -Math.max(...blocks.map(b=>b.y)) - 1;
    return {blocks, x:offsetX, y:offsetY, key};
  }

  function cellMetrics(){
    const style = getComputedStyle(document.documentElement);
    const cell = parseFloat(style.getPropertyValue('--cell-size')) ;
    const gap = parseFloat(style.getPropertyValue('--gap'));
    const padding = 12; // board padding
    return {cell, gap, padding};
  }

  // Manage tile elements by id key 'r-c' for grid, and 'cur-i' for current moving
  function ensureTile(id, val){
    if (!tileLayer) return null;
    let el = tileLayer.querySelector(`[data-id='${id}']`);
    if (!el){
      el = document.createElement('div');
      el.className = 'tile-el';
      el.setAttribute('data-id', id);
      el.innerHTML = `<div class='label'></div>`;
      tileLayer.appendChild(el);
    }
    el.setAttribute('data-val', val);
    el.querySelector('.label').textContent = val;
    return el;
  }

  function removeTile(id){ if (!tileLayer) return; const el = tileLayer.querySelector(`[data-id='${id}']`); if (el) el.remove(); }

  // Draw function: update tiles to reflect grid + current piece
  function draw(){
    const {cell,gap,padding} = cellMetrics();
    const tileIds = new Set();

    if (!tileLayer) return;

    // draw grid
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
      const v = grid[r][c];
      const id = `g-${r}-${c}`;
      if (v){
        const el = ensureTile(id, v);
        if (!el) continue;
        tileIds.add(id);
        const left = c*(cell+gap);
        const top = r*(cell+gap);
        el.style.left = `${left}px`;
        el.style.top = `${top}px`;
        el.style.width = `${cell}px`;
        el.style.height = `${cell}px`;
      } else {
        removeTile(id);
      }
    }

    // draw current piece
    if (current){
      current.blocks.forEach((b, idx)=>{
        const r = current.y + b.y;
        const c = current.x + b.x;
        const id = `cur-${idx}`;
        const val = b.v;
        const el = ensureTile(id, val);
        if (!el) return;
        tileIds.add(id);
        const left = c*(cell+gap);
        const top = r*(cell+gap);
        el.style.left = `${left}px`;
        el.style.top = `${top}px`;
        el.style.width = `${cell}px`;
        el.style.height = `${cell}px`;
      });
    } else {
      // remove any cur-* tiles that remained
      tileLayer.querySelectorAll('[data-id^="cur-"]').forEach(e=>e.remove());
    }

    // cleanup orphan tiles
    tileLayer.querySelectorAll('[data-id]').forEach(el=>{
      const id = el.getAttribute('data-id');
      if (!tileIds.has(id)) el.remove();
    });
  }

  // Next preview (simple grid cells)
  function drawNext(){
    nextEl.innerHTML = '';
    for (let i=0;i<16;i++){ const d = document.createElement('div'); d.className='cell-bg'; nextEl.appendChild(d);}    
    if (!nextPiece) return;
    nextPiece.blocks.forEach(b=>{
      const r = b.y + 1; const c = b.x + 1; const idx = r*4 + c;
      if (idx>=0 && idx<nextEl.children.length){
        const el = nextEl.children[idx];
        el.className = '';
        el.style.borderRadius='8px';
        el.textContent = b.v; el.style.fontWeight = 800; el.style.display='flex'; el.style.alignItems='center'; el.style.justifyContent='center';
        el.style.background = "#f1efe9";
        el.style.color = "black";
      }
    });
  }

  function collides(x,y,blocks){
    for (const b of blocks){
      const r = y + b.y;
      const c = x + b.x;
      if (c<0 || c>=COLS) return true;
      if (r>=ROWS) return true;
      if (r>=0 && grid[r][c]) return true;
    }
    return false;
  }

  function move(dx, dy, playMoveSound = false){
    if (!current) return false;
    if (!collides(current.x + dx, current.y + dy, current.blocks)){
      current.x += dx; current.y += dy; 
      if (playMoveSound) {
        playSound('move'); // Воспроизводим звук перемещения только если указано
      }
      draw(); 
      return true;
    }
    return false;
  }

  function rotate(){
    if (!current) return;
    const newBlocks = current.blocks.map(b=>({x: b.y, y: -b.x, v: b.v}));
    const minX = Math.min(...newBlocks.map(b=>b.x));
    const minY = Math.min(...newBlocks.map(b=>b.y));
    newBlocks.forEach(b=>{ b.x -= minX; b.y -= minY; });
    if (!collides(current.x, current.y, newBlocks)){
      current.blocks = newBlocks; 
      playSound('rotate'); // Воспроизводим звук вращения
      draw();
    } else {
      if (!collides(current.x-1, current.y, newBlocks)) { current.x -=1; current.blocks=newBlocks; draw(); }
      else if (!collides(current.x+1, current.y, newBlocks)) { current.x +=1; current.blocks=newBlocks; draw(); }
    }
  }

  function hardDrop(){
    if (!current) return;
    while(move(0,1, false)){}
    playSound('drop'); // Воспроизводим звук падения
    lockPiece();
  }

  // Новая функция для проверки горизонтальных слияний
  function checkHorizontalMerges(placedBlocks) {
    const mergedCells = [];
    const processed = new Set();
    
    // Проверяем каждый блок, который был только что размещен
    for (const [r, c] of placedBlocks) {
      const key = `${r},${c}`;
      if (processed.has(key)) continue;
      
      const val = grid[r][c];
      if (!val) continue;
      
      // Ищем компонент связности по горизонтали (слева и справа)
      const component = [];
      const queue = [[r, c]];
      processed.add(key);
      
      while (queue.length > 0) {
        const [cr, cc] = queue.shift();
        component.push([cr, cc]);
        
        // Проверяем только горизонтальных соседей (слева и справа)
        const left = cc - 1;
        const right = cc + 1;
        
        if (left >= 0 && grid[cr][left] === val && !processed.has(`${cr},${left}`)) {
          processed.add(`${cr},${left}`);
          queue.push([cr, left]);
        }
        
        if (right < COLS && grid[cr][right] === val && !processed.has(`${cr},${right}`)) {
          processed.add(`${cr},${right}`);
          queue.push([cr, right]);
        }
      }
      
      // Если компонент содержит 2 или более плитки, добавляем его в список для слияния
      if (component.length >= 2) {
        mergedCells.push(component);
      }
    }
    
    return mergedCells;
  }

  // Новая функция для выполнения горизонтальных слияний
  function performHorizontalMerges(mergedComponents) {
    const anims = [];
    
    for (const component of mergedComponents) {
      if (component.length < 2) continue;
      
      const val = grid[component[0][0]][component[0][1]];
      
      // Определяем множитель в зависимости от размера компонента
      let multiplier;
      if (component.length === 2) multiplier = 2;
      else if (component.length === 3) multiplier = 2;
      else multiplier = 4;
      
      const mergedVal = val * multiplier;
      
      // Выбираем ячейку для слияния - предпочтительно центральную
      const centerIndex = Math.floor(component.length / 2);
      const [mr, mc] = component[centerIndex];
      
      // Очищаем все ячейки компонента
      for (const [r, c] of component) {
        grid[r][c] = 0;
      }
      
      // Размещаем объединенную плитку
      grid[mr][mc] = mergedVal;
      
      // Обновляем счет
      score += mergedVal;
      updateScoreAndLevel();
      
      anims.push({r: mr, c: mc, val: mergedVal, size: component.length});
      playSound('merge');
    }
    
    return anims;
  }

  // Новая механика слияния (расширенная):
  // processMerges(optionalLimitSet):
  // - если optionalLimitSet задан (Set строковых ключей "r,c"), то будут обработаны только компоненты, которые пересекаются с этим множеством (приоритетные слияния)
  // - иначе — полная обработка по всему полю.
  function processMerges(limitSet = null){
    let anyMerged = false;
    const anims = [];
    const visited = Array.from({length:ROWS},()=>Array(COLS).fill(false));
    
    // helper to get neighbors
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (visited[r][c] || !grid[r][c]) continue;
        
        // BFS component of equal-value tiles
        const val = grid[r][c];
        const component = [];
        const queue = [[r,c]];
        visited[r][c] = true;
        while(queue.length){
          const [cr, cc] = queue.shift();
          component.push([cr, cc]);
          for (const [dr, dc] of dirs){
            const nr = cr + dr; const nc = cc + dc;
            if (nr<0||nr>=ROWS||nc<0||nc>=COLS) continue;
            if (visited[nr][nc] || grid[nr][nc] !== val) continue;
            visited[nr][nc] = true;
            queue.push([nr, nc]);
          }
        }

        // if limitSet is provided and component doesn't intersect it -> skip
        if (limitSet){
          let intersects = false;
          for (const [cr,cc] of component){
            if (limitSet.has(`${cr},${cc}`)){ intersects = true; break; }
          }
          if (!intersects) continue;
        }

        if (component.length >= 2){
          anyMerged = true;

          // multiplier logic preserved
          let multiplier;
          if (component.length === 2) multiplier = 2;
          else if (component.length === 3) multiplier = 2;
          else multiplier = 4;

          const mergedVal = val * multiplier;

          // choose merge cell: prefer the cell in component that has the most non-component neighbors
          // (this biases towards side ближе к другим плиткам)
          const neighborCounts = component.map(([cr,cc])=>{
            let count = 0;
            for (const [dr,dc] of dirs){
              const nr = cr + dr, nc = cc + dc;
              if (nr<0||nr>=ROWS||nc<0||nc>=COLS) continue;
              // count neighbors that are non-zero and not part of this component
              if (grid[nr][nc] && !component.some(p => p[0]===nr && p[1]===nc)) count++;
            }
            return count;
          });

          // find best index: highest neighborCounts; tie-breaker: higher row (smaller r), then closer to center
          let bestIdx = 0;
          for (let i=1;i<component.length;i++){
            if (neighborCounts[i] > neighborCounts[bestIdx]) bestIdx = i;
            else if (neighborCounts[i] === neighborCounts[bestIdx]){
              // prefer higher (smaller r)
              if (component[i][0] < component[bestIdx][0]) bestIdx = i;
              else if (component[i][0] === component[bestIdx][0]){
                const centerCol = Math.floor(COLS/2);
                const distI = Math.abs(component[i][1] - centerCol);
                const distB = Math.abs(component[bestIdx][1] - centerCol);
                if (distI < distB) bestIdx = i;
              }
            }
          }

          // clear all component cells
          for (const [cr, cc] of component) grid[cr][cc] = 0;

          const [mr, mc] = component[bestIdx];
          grid[mr][mc] = mergedVal;

          // score update
          score += mergedVal;
          updateScoreAndLevel();

          anims.push({r: mr, c: mc, val: mergedVal, size: component.length});
          playSound('merge');
        }
      }
    }

    return {anyMerged, anims};
  }

  function applyGravity(){
    for (let c=0;c<COLS;c++){
      let write = ROWS-1;
      for (let r=ROWS-1;r>=0;r--){
        if (grid[r][c]){
          if (r !== write){ grid[write][c] = grid[r][c]; grid[r][c] = 0; }
          write--;
        }
      }
    }
  }

  // animate merges: pop, spawn particles, show praise
  function animateMerges(anims){
    if (!anims || anims.length===0) return;
    const {cell,gap} = cellMetrics();
    for (const a of anims){
      const id = `g-${a.r}-${a.c}`;
      const el = tileLayer.querySelector(`[data-id='${id}']`);
      if (el){
        el.classList.add('merge-anim');
        setTimeout(()=>el.classList.remove('merge-anim'), 520);
      }
      // spawn particles
      const originLeft = a.c*(cell+gap) + cell/2;
      const originTop = a.r*(cell+gap) + cell/2;
      spawnParticles(originLeft, originTop, Math.min(12, 3 + Math.floor(a.size/2)));
      // show praise
      const praise = choosePraise(a.val, a.size);
      showPraise(praise, originLeft, originTop);
    }
  }

  function spawnParticles(x,y,count){
    for (let i=0;i<count;i++){
      const p = document.createElement('div');
      p.className = 'particle';
      p.style.left = `${x - 5}px`;
      p.style.top = `${y - 5}px`;
      // random direction
      const angle = (Math.random()*Math.PI*2);
      const dist = 40 + Math.random()*40;
      const dx = Math.cos(angle)*dist + 'px';
      const dy = Math.sin(angle)*dist - 20 + 'px';
      p.style.setProperty('--dx', dx);
      p.style.setProperty('--dy', dy);
      const dur = 700 + Math.random()*300;
      p.style.animation = `starFly ${dur}ms cubic-bezier(.2,.9,.2,1) forwards`;
      tileLayer.appendChild(p);
      // remove after animation
      setTimeout(()=>{ p.remove(); }, dur + 50);
    }
  }

  function choosePraise(val, size){
    // bigger merges get stronger praise
    if (val >= 1024) return t('praise.bombastic');
    if (val >= 512) return t('praise.amazing');
    if (val >= 128) return t('praise.excellent');
    if (size >= 4) return t('praise.great');
    if (size >= 3) return t('praise.good');
    return t('praise.super');
  }

  function showPraise(text, x, y){
    const p = document.createElement('div');
    p.className = 'praise';
    p.textContent = text;
    // position relative to tileLayer
    p.style.left = `${x}px`;
    p.style.top = `${y}px`;
    tileLayer.appendChild(p);
    // force reflow then show
    requestAnimationFrame(()=>{ p.classList.add('show'); });
    setTimeout(()=>{ p.classList.remove('show'); setTimeout(()=>p.remove(),500); }, 1200);
  }

  function showCombo(count, x, y){
    if (count <= 1) return;
    
    // Воспроизводим разные звуки в зависимости от размера комбо
    if (count > 4) {
      playSound('megacombo'); // Воспроизводим звук мега-комбо
    } else {
      playSound('combo'); // Воспроизводим обычный звук комбо
    }
    
    const p = document.createElement('div');
    p.className = 'combo';
    p.textContent = `COMBO x${count}`;
    p.style.left = `${x}px`;
    p.style.top = `${y - 20}px`;
    tileLayer.appendChild(p);
    requestAnimationFrame(()=>{ p.classList.add('show'); });
    setTimeout(()=>{ p.classList.remove('show'); setTimeout(()=>p.remove(),400); }, 1000);
  }

  function showNewRecord() {
    if (newRecordShown) return;
    newRecordShown = true;
    
    // Воспроизводим звук нового рекорда только если он еще не был воспроизведен на этом уровне
    if (!newRecordSoundPlayed) {
      playSound('newrecord'); // Воспроизводим звук нового рекорда
      newRecordSoundPlayed = true;
    }
    
    const newRecordEl = document.getElementById('newRecord');
    newRecordEl.classList.add('show');
    setTimeout(() => {
      newRecordEl.classList.remove('show');
      // Не сбрасываем newRecordShown здесь, чтобы уведомление не появлялось снова
    }, 3000);
  }

  // НОВАЯ ЛОГИКА: функция для выполнения всех возможных слияний без гравитации
  function performAllMerges() {
    let totalMerges = 0;
    let totalAnims = [];
    
    function mergeLoop() {
      const res = processMerges();
      if (res.anyMerged) {
        totalMerges++;
        comboChain++;
        totalAnims = totalAnims.concat(res.anims);
        
        // Анимируем текущие слияния
        draw();
        animateMerges(res.anims);
        
        // Показываем комбо для цепочки слияний
        if (res.anims && res.anims.length > 0) {
          const a = res.anims[0];
          const {cell,gap} = cellMetrics();
          const originLeft = a.c*(cell+gap) + cell/2;
          const originTop = a.r*(cell+gap) + cell/2;
          showCombo(comboChain, originLeft, originTop);
        }
        
        // Рекурсивно продолжаем проверять слияния
        setTimeout(mergeLoop, 420);
      } else {
        // Все слияния завершены, применяем гравитацию
        setTimeout(() => {
          applyGravity();
          draw();
          
          // После гравитации проверяем, не появились ли новые возможности для слияния
          setTimeout(() => {
            const afterGravityRes = processMerges();
            if (afterGravityRes.anyMerged) {
              // Если после гравитации есть новые слияния, запускаем процесс заново
              performAllMerges();
            } else {
              // Все слияния завершены, спавним следующую фигуру
              if (comboChain > 1){
                const centerX = (COLS/2) * (cellMetrics().cell + cellMetrics().gap);
                const centerY = (ROWS/3) * (cellMetrics().cell + cellMetrics().gap);
                showPraise(comboChain >= 4 ? t('praise.comboMaster') : t('praise.classicCombo'), centerX, centerY);
              }
              spawnNext();
            }
          }, 220);
        }, totalMerges > 0 ? 420 : 0);
      }
    }
    
    mergeLoop();
  }

  // lockPiece: при блокировке выполняем приоритетные боковые слияния вокруг только что упавших блоков,
  // затем применяем новую логику слияний
  function lockPiece(){
    if (!current) return;
    
    // Очищаем список только что упавших блоков
    justPlacedBlocks = [];
    
    // place into grid
    for (const b of current.blocks){
      const r = current.y + b.y; 
      const c = current.x + b.x;
      if (r<0) { return gameOver(); }
      grid[r][c] = b.v;
      justPlacedBlocks.push([r, c]);
    }

    current = null;
    // НЕ сбрасываем comboChain здесь, чтобы сохранить его между горизонтальными и последующими слияниями

    // ---------- НОВАЯ ЛОГИКА: сначала горизонтальные слияния, затем все остальные слияния ----------
    
    // Сначала проверяем и выполняем горизонтальные слияния
    const horizontalMerges = checkHorizontalMerges(justPlacedBlocks);
    let horizontalMergeAnims = [];
    
    if (horizontalMerges.length > 0) {
      horizontalMergeAnims = performHorizontalMerges(horizontalMerges);
      // Увеличиваем comboChain только если он еще не был увеличен
      if (comboChain === 0) comboChain = 1;
      draw();
      animateMerges(horizontalMergeAnims);
      
      // Показываем комбо для горизонтальных слияний
      if (horizontalMergeAnims.length > 0) {
        const a = horizontalMergeAnims[0];
        const {cell,gap} = cellMetrics();
        const originLeft = a.c*(cell+gap) + cell/2;
        const originTop = a.r*(cell+gap) + cell/2;
        showCombo(comboChain, originLeft, originTop);
      }
      
      // После горизонтальных слияний применяем гравитацию
      setTimeout(() => {
        applyGravity();
        draw();
        
        // Затем запускаем полный процесс слияний
        setTimeout(() => {
          performAllMerges();
        }, 220);
      }, 420);
    } else {
      // Если горизонтальных слияний нет, сразу запускаем полный процесс слияний
      comboChain = 0; // Сбрасываем comboChain только если не было горизонтальных слияний
      performAllMerges();
    }
  }

  function spawnNext(){
    if (!nextPiece) nextPiece = makePiece();
    current = {blocks: nextPiece.blocks.map(b=>({x:b.x,y:b.y,v:b.v})), x: nextPiece.x, y: nextPiece.y, key: nextPiece.key};
    nextPiece = makePiece();
    drawNext();
    draw();
    // Сбрасываем цепочку комбо при появлении новой фигуры
    comboChain = 0;
    // if immediately collides -> game over
    if (collides(current.x, current.y, current.blocks)){
      gameOver();
    }
  }

  function updateScoreAndLevel(){
    scoreEl.textContent = score;
    restartTimer();
    if (score > best){ 
      best = score; 
      bestEl.textContent = best; 
      localStorage.setItem('tetris2048_best', best); 
      // Показываем новый рекорд только если текущий счет превысил предыдущий рекорд
      if (score > currentBest) {
        showNewRecord();
        currentBest = score;
      }
    }
  }

  function step(){
    if (paused || leaderboardPaused) return;
    if (!current) return;
    // try move down without playing sound
    if (move(0,1, false)){
      // cancel settle if moving
      if (settleTimer){ clearTimeout(settleTimer); settleTimer = null; dropSoundPending = false; }
      draw();
    } else {
      // cannot move down -> start settle timer to avoid immediate snap bug
      if (!settleTimer){
        // play drop sound only once when first contacting the floor/another tile
        if (!dropSoundPending){
          playSound('drop');
          dropSoundPending = true;
        }
        settleTimer = setTimeout(()=>{ 
          settleTimer = null; 
          dropSoundPending = false;
          lockPiece(); 
        }, SETTLE_MS);
      }
    }
  }

  function restartTimer(){ 
    if (timer) clearInterval(timer); 
    timer = setInterval(step, tick); 
  }

  function startGame(){ 
    resetGrid(); 
    createBoard(); 
    draw(); 
    score = 0; 
    tick = TICK_START; 
    paused = false; 
    leaderboardPaused = false;
    current = null; 
    nextPiece = null; 
    justPlacedBlocks = []; // Очищаем список только что упавших блоков
    newRecordShown = false;
    newRecordSoundPlayed = false; // Сбрасываем флаг звука нового рекорда
    comboChain = 0; // Сбрасываем цепочку комбо
    currentBest = best; // Сбрасываем текущий лучший счет для этой игры
    spawnNext(); 
    scoreEl.textContent='0'; 
    restartTimer(); 
    overlay.classList.remove('show'); 
    gameStarted = true;
    
    // Start gameplay
    if (ysdk && ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.start();
    }
    
    // Ensure audio context resumed if required and start BG music
    if (soundEnabled) {
      resumeAudioSystem();
    }
  }

  function gameOver(){ 
    clearInterval(timer); 
    current = null; 
    draw(); 
    playSound('gameover'); // Воспроизводим звук окончания игры
    stopBackgroundMusic(); // Останавливаем фоновую музыку
    gameStarted = false;
    
    // Stop gameplay
    if (ysdk && ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.stop();
    }
    
    // Submit score to leaderboard
    if (score > 0) {
      submitScore(score).then(() => {
        // После обновления данных обновляем отображение лучшего счета
        bestEl.textContent = best;
      }).catch(err => {
        console.error('Error updating player score:', err);
      });
    }
    
    modal.innerHTML = `<div style="font-size:18px;font-weight:700;margin-bottom:8px">${t('game.gameOver')}</div><div class="small">${t('ui.score')}: ${score}</div><div style="height:10px"></div><div style="display:flex;gap:8px"><button id=again>${t('ui.playAgain')}</button><button id=close class='secondary'>${t('ui.close')}</button></div>`; 
    overlay.classList.add('show'); 
    document.getElementById('again').onclick = ()=>{ overlay.classList.remove('show'); startGame(); }; 
    document.getElementById('close').onclick = ()=>{ overlay.classList.remove('show'); } 
  }

  // Функция для отображения/скрытия меню паузы
  function togglePause() {
    paused = !paused;
    
    if (paused) {
      // Stop gameplay
      if (ysdk && ysdk.features.GameplayAPI) {
        ysdk.features.GameplayAPI.stop();
      }
      
      if (timer) clearInterval(timer);
      suspendAudioSystem();
      pauseMenuEl.classList.add('show');
    } else {
      pauseMenuEl.classList.remove('show');
      restartTimer();
      
      // Start gameplay
      if (ysdk && ysdk.features.GameplayAPI) {
        ysdk.features.GameplayAPI.start();
      }
      
      // resume audio system (background music) if allowed
      resumeAudioSystem();
    }
  }

  // input
  document.addEventListener('keydown', e=>{
    if (e.repeat) return;
    if (e.key === 'ArrowLeft'){ move(-1,0, true); draw(); e.preventDefault(); }
    else if (e.key === 'ArrowRight'){ move(1,0, true); draw(); e.preventDefault(); }
    else if (e.key === 'ArrowDown'){ move(0,1, true); draw(); e.preventDefault(); }
    else if (e.key === 'ArrowUp'){ rotate(); draw(); e.preventDefault(); }
    else if (e.code === 'Space'){ hardDrop(); e.preventDefault(); }
    else if (e.key.toLowerCase() === 'p' || e.key === 'Escape'){
      if (!leaderboardPaused) {
        togglePause();
      }
      e.preventDefault();
    }
  });

  // safe UI buttons
  (function(){ 
    const restartBtn = document.getElementById('restart'); 
    if (restartBtn) restartBtn.addEventListener('click', ()=>startGame()); 
  })();

  // Start button
  startButtonEl.addEventListener('click', () => {
    startScreenEl.style.display = 'none';
    startGame();
  });

  // Pause button
  pauseToggleEl.addEventListener('click', togglePause);

  // Pause menu buttons
  resumeButtonEl.addEventListener('click', () => {
    paused = false;
    pauseMenuEl.classList.remove('show');
    restartTimer();
    
    // Start gameplay
    if (ysdk && ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.start();
    }
    
    resumeAudioSystem();
  });

  restartButtonEl.addEventListener('click', () => {
    pauseMenuEl.classList.remove('show');
    startGame();
  });

  soundButtonEl.addEventListener('click', () => {
    toggleSound();
  });

  // Leaderboard button
  leaderboardButtonEl.addEventListener('click', () => {
    pauseMenuEl.classList.remove('show');
    
    // Pause the game for leaderboard without showing pause menu
    leaderboardPaused = true;
    
    // Stop gameplay
    if (ysdk && ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.stop();
    }
    
    // Pause game and audio
    if (timer) clearInterval(timer);
    suspendAudioSystem();
    
    loadLeaderboard();
    leaderboardOverlayEl.classList.add('show');
  });

  leaderboardCloseEl.addEventListener('click', () => {
    leaderboardOverlayEl.classList.remove('show');
    
    // Resume game after closing leaderboard
    leaderboardPaused = false;
    
    // Start gameplay
    if (ysdk && ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.start();
    }
    
    // Resume game and audio
    restartTimer();
    resumeAudioSystem();
  });

  // Leaderboard button in side panel
  document.getElementById('leaderboard').addEventListener('click', () => {
    // Pause the game for leaderboard without showing pause menu
    leaderboardPaused = true;
    
    // Stop gameplay
    if (ysdk && ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.stop();
    }
    
    // Pause game and audio
    if (timer) clearInterval(timer);
    suspendAudioSystem();
    
    loadLeaderboard();
    leaderboardOverlayEl.classList.add('show');
  });

  // Initialize Yandex SDK
  initYandexSDK().then(() => {
    console.log('Yandex SDK initialized successfully');
    // Set up game pause/resume events
    ysdk.on('game_api_pause', () => {
      if (!paused && gameStarted && !leaderboardPaused) {
        togglePause();
      }
    });
    
    ysdk.on('game_api_resume', () => {
      if (paused && gameStarted && !leaderboardPaused) {
        togglePause();
      }
    });
    
    // Start game loop for ads
    setInterval(() => {
      if (gameStarted && !paused && !leaderboardPaused) {
        showAd();
      }
    }, AD_INTERVAL);
  }).catch(err => {
    console.error('Failed to initialize Yandex SDK:', err);
    // Fallback to local storage if SDK not available
    startScreenEl.style.display = 'flex';
    
    // Try to detect language from browser
    currentLanguage = getCurrentLanguage();
    updateTranslations();
  });

  // initialization
  resetGrid(); 
  createBoard(); 
  nextPiece = makePiece(); 
  drawNext(); 

})();
</script>
</body>
</html>