<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>Плитки</title>

  <script src="/sdk.js"></script>
  <style>
    :root{
      --cell-size: 40px;
      --cols: 6;
      --rows: 12;
      --gap: 6px;
      --bg:#071026;
      --panel:#0f1720;
      --muted:#9aa4b2;
      --scale: 1;
    }
    *{box-sizing:border-box;font-family:Inter, system-ui, Arial, sans-serif;-webkit-tap-highlight-color:transparent;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}
    html,body{height:100%;overflow: hidden; margin:0;background-image:url('background.jpg');background-size:cover;background-position:center;color:#e6eef6;overflow-x:hidden;touch-action:manipulation}

    /* layout */
    .app{display:flex;gap:16px;align-items:flex-start;justify-content: center; max-width:1100px;margin:12px auto; height: 100vh; transform: scale(var(--scale)); transform-origin: top center;}
    .board-wrap{background:linear-gradient(180deg,rgba(9,16,37,0.9),rgba(7,16,32,0.9));padding:12px;border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,0.6);position:relative}

    /* board grid (visual guide) */
    .board{position:relative;display:grid;grid-template-columns:repeat(var(--cols),var(--cell-size));grid-template-rows:repeat(var(--rows),var(--cell-size));gap:var(--gap);background:rgba(6,18,37,0.9);padding:12px;border-radius:10px;min-height:calc(var(--rows) * var(--cell-size) + (var(--rows)-1)*var(--gap));overflow:hidden}

    /* static cell background to keep grid look */
    .cell-bg{width:var(--cell-size);height:var(--cell-size);border-radius:8px;background:rgba(255,255,255,0.02);box-shadow:inset 0 -3px rgba(0,0,0,0.2)}

    /* floating tile elements for animation */
    .tile-el{position:absolute;width:var(--cell-size);height:var(--cell-size);display:flex;align-items:center;justify-content:center;border-radius:8px;font-weight:800;transition:transform 220ms cubic-bezier(.2,.9,.2,1), top 220ms cubic-bezier(.2,.9,.2,1), left 220ms cubic-bezier(.2,.9,.2,1);box-shadow:0 6px 18px rgba(2,6,23,0.6);pointer-events:none}
    .tile-el .label{transform:translateY(1px)}
    
    /* ИСПРАВЛЕНО: правильная анимация падения с переопределением всех переходов */
    .tile-el.falling{transition:transform 220ms cubic-bezier(.2,.9,.2,1), top 250ms cubic-bezier(.2,.6,.3,1), left 250ms cubic-bezier(.2,.6,.3,1) !important}

    /* merge animation */
    .merge-anim{animation:mergePop 320ms ease forwards}
    @keyframes mergePop{0%{transform:scale(1)}40%{transform:scale(1.6)}100%{transform:scale(1)}}

    /* particle (star) */
    .particle{position:absolute;width:10px;height:10px;border-radius:50%;background:gold;box-shadow:0 0 8px gold, 0 0 20px rgba(255,200,50,0.6);pointer-events:none;opacity:0}
    @keyframes starFly{
      0%{opacity:1;transform:translate(0,0) scale(1)}
      60%{opacity:1}
      100%{opacity:0;transform:translate(var(--dx),var(--dy)) scale(0.6)}
    }

    /* praise text */
    .praise{position:absolute;font-weight:800;color:#fff;text-shadow:0 4px 16px rgba(0,0,0,0.6);pointer-events:none;opacity:0;transform:translateY(0);transition:transform 480ms cubic-bezier(.2,.9,.2,1),opacity 480ms}
    .praise.show{opacity:1;transform:translateY(-40px)}

    /* combo text */
    .combo{position:absolute;font-weight:900;color:#ffd86b;text-shadow:0 6px 18px rgba(0,0,0,0.6);pointer-events:none;opacity:0;transform:translateY(0);transition:transform 420ms cubic-bezier(.2,.9,.2,1),opacity 420ms;font-size:20px}
    .combo.show{opacity:1;transform:translateY(-36px) scale(1.05)}

    /* combo text */
    .combo-bonus{position:absolute;font-weight:900;color:#ff6b6b;text-shadow:0 6px 18px rgba(0,0,0,0.6);pointer-events:none;opacity:0;transform:translateY(0);transition:transform 420ms cubic-bezier(.2,.9,.2,1),opacity 420ms;font-size:18px}
    .combo-bonus.show{opacity:1;transform:translateY(-36px) scale(1.05)}

    /* new record notification */
    .new-record{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);font-weight:900;color:#ffd86b;font-size:28px;text-shadow:0 6px 18px rgba(0,0,0,0.6);pointer-events:none;opacity:0;z-index:50;transition:transform 480ms cubic-bezier(.2,.9,.2,1),opacity 480ms}
    .new-record.show{opacity:1;transform:translate(-50%, -50%) scale(1.1)}

    /* tile colors (use data-val attribute) */
    .tile-el[data-val="2"]{background:linear-gradient(180deg,#f1efe9,#efe8d6);color:#2b2b2b}
    .tile-el[data-val="4"]{background:linear-gradient(180deg,#f3e7d7,#f0d8b7);color:#2b2b2b}
    .tile-el[data-val="8"]{background:linear-gradient(180deg,#f7cf95,#f0b46b);color:#111}
    .tile-el[data-val="16"]{background:linear-gradient(180deg,#f09e5b,#e67a3b);color:#fff}
    .tile-el[data-val="32"]{background:linear-gradient(180deg,#e86e4b,#c94c2f);color:#fff}
    .tile-el[data-val="64"]{background:linear-gradient(180deg,#d44c8a,#b7306f);color:#fff}
    .tile-el[data-val="128"]{background:linear-gradient(180deg,#6db7f7,#3b8fe8);color:#fff}
    .tile-el[data-val="256"]{background:linear-gradient(180deg,#74d7b2,#2db386);color:#042018}
    .tile-el[data-val="512"]{background:linear-gradient(180deg,#a293ff,#7a5dff);color:#fff}
    .tile-el[data-val="1024"]{background:linear-gradient(180deg,#ffd86b,#ffb84f);color:#111}
    .tile-el[data-val="2048"]{background:linear-gradient(180deg,#ffe0a9,#ffd676);color:#111}

    /* side panel */
    .side{display:flex;flex-direction:column;gap:12px;width:260px}
    .panel{background:var(--panel);padding:12px;border-radius:8px;box-shadow:inset 0 -4px rgba(0,0,0,.25)}
    .title{font-size:18px;font-weight:700;margin-bottom:6px}
    .stat{font-size:18px;color:var(--muted)}
    button{padding:10px;border-radius:8px;border:0;background:#0f1726;color:#dfe9f8;cursor:pointer}
    button.secondary{background:#121827;color:var(--muted)}
    .next-piece{display:grid;grid-template-columns:repeat(4,40px);grid-auto-rows:40px;gap:6px;justify-content:center}
    .footer{font-size:13px;color:var(--muted);margin-top:8px}
    .controls-list{font-size:13px;color:var(--muted);display:block;line-height:1.6}
    .hint{font-size:13px;color:#bcd0ff}
    .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:100}
    .overlay.show{display:flex}
    .modal{background:#0c1320;padding:24px;border-radius:12px;box-shadow:0 10px 40px rgba(0,0,0,0.6);max-width:90vw;max-height:90vh;overflow:auto}
    .small{font-size:12px;color:var(--muted)}
    
    /* Sound toggle button */
    .sound-toggle {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: rgba(15, 23, 38, 0.8);
      border: none;
      color: #dfe9f8;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      z-index: 10;
      transition: background 0.2s;
    }
    .sound-toggle:hover {
      background: rgba(15, 23, 38, 1);
    }
    .sound-toggle.muted {
      opacity: 0.5;
    }
    
    /* Pause button */
    .pause-toggle {
      position: absolute;
      top: 12px;
      right: 54px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: rgba(15, 23, 38, 0.8);
      border: none;
      color: #dfe9f8;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      z-index: 10;
      transition: background 0.2s;
    }
    .pause-toggle:hover {
      background: rgba(15, 23, 38, 1);
    }
    
    /* Start screen */
    .start-screen {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(5, 6, 10, 0.9);
      z-index: 200;
    }
    .start-modal {
      background: #0c1320;
      padding: 32px;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      max-width: 400px;
      text-align: center;
    }
    .start-title {
      font-size: 32px;
      font-weight: 900;
      margin-bottom: 20px;
      background: linear-gradient(180deg, #ffd86b, #ffb84f);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .start-description {
      font-size: 16px;
      color: #e6eef6;
      margin-bottom: 24px;
      line-height: 1.5;
    }
    .start-button {
      opacity: 0;
      padding: 12px 24px;
      font-size: 18px;
      font-weight: 700;
      background: linear-gradient(180deg, #3b8fe8, #2a6ac4);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .start-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(59, 143, 232, 0.4);
    }
    
    /* Pause menu */
    .pause-menu {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(5, 6, 10, 0.9);
      z-index: 150;
    }
    .pause-menu.show {
      display: flex;
    }
    .pause-modal {
      background: #0c1320;
      padding: 32px;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      max-width: 400px;
      text-align: center;
    }
    .pause-title {
      font-size: 28px;
      font-weight: 900;
      margin-bottom: 20px;
      color: #e6eef6;
    }
    .pause-buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .pause-button {
      padding: 12px 24px;
      font-size: 16px;
      font-weight: 700;
      background: #0f1726;
      color: #dfe9f8;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s, background 0.2s;
    }
    .pause-button:hover {
      transform: translateY(-2px);
      background: #1a2332;
    }
    .pause-button.primary {
      background: linear-gradient(180deg, #3b8fe8, #2a6ac4);
      color: white;
    }
    .pause-button.primary:hover {
      background: linear-gradient(180deg, #4a9cf8, #3979d4);
    }
    
    /* Leaderboard styles */
    .leaderboard {
      background: #0c1320;
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }
    .leaderboard-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 16px;
      color: #e6eef6;
      text-align: center;
    }
    .leaderboard-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .leaderboard-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 12px;
      background: rgba(15, 23, 38, 0.5);
      border-radius: 8px;
    }
    .leaderboard-item.current-player {
      background: rgba(59, 143, 232, 0.3);
      border: 1px solid rgba(59, 143, 232, 0.5);
    }
    .leaderboard-rank {
      font-weight: 700;
      color: #ffd86b;
      width: 30px;
    }
    .leaderboard-name {
      flex-grow: 1;
      margin: 0 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .leaderboard-score {
      font-weight: 700;
      color: #e6eef6;
    }
    .leaderboard-close {
      margin-top: 16px;
      width: 100%;
    }
    .leaderboard-loading {
      text-align: center;
      padding: 20px;
      color: var(--muted);
    }
    .leaderboard-empty {
      text-align: center;
      padding: 20px;
      color: var(--muted);
    }
    .leaderboard-separator {
      text-align: center;
      padding: 10px;
      color: var(--muted);
      font-size: 14px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      margin-top: 10px;
    }
    
    /* Custom scrollbar for leaderboard */
    .leaderboard::-webkit-scrollbar {
      width: 8px;
    }
    .leaderboard::-webkit-scrollbar-track {
      background: rgba(15, 23, 38, 0.3);
      border-radius: 4px;
    }
    .leaderboard::-webkit-scrollbar-thumb {
      background: rgba(59, 143, 232, 0.7);
      border-radius: 4px;
    }
    .leaderboard::-webkit-scrollbar-thumb:hover {
      background: rgba(59, 143, 232, 0.9);
    }
    
    /* Second chance button */
    .second-chance-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 24px;
      font-size: 16px;
      font-weight: 700;
      background: linear-gradient(180deg, #f7cf95, #f0b46b);
      color: #111;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .second-chance-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(247, 207, 149, 0.4);
    }
    .second-chance-btn img {
      width: 24px;
      height: 24px;
    }
    
    /* Ad warning notification */
    .ad-warning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(12, 19, 32, 0.95);
      padding: 20px 30px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
      z-index: 120;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-width: 250px;
      border: 2px solid rgba(59, 143, 232, 0.5);
    }
    .ad-warning.show {
      display: flex;
      animation: fadeIn 0.3s ease-out;
    }
    .ad-warning-text {
      font-size: 18px;
      font-weight: 700;
      color: #e6eef6;
      margin-bottom: 15px;
      text-align: center;
    }
    .ad-warning-timer {
      font-size: 36px;
      font-weight: 900;
      color: #ffd86b;
      text-shadow: 0 2px 10px rgba(255, 216, 107, 0.5);
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
      to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }
    
    /* First place notification */
    .first-place {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-weight: 900;
      color: #ffd86b;
      font-size: 28px;
      text-shadow: 0 6px 18px rgba(0,0,0,0.6);
      pointer-events: none;
      opacity: 0;
      z-index: 50;
      transition: transform 480ms cubic-bezier(.2,.9,.2,1), opacity 480ms;
      text-align: center;
      width: 80%;
    }
    .first-place.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.1);
    }
    
    /* Responsive adjustments */
    @media (max-width: 620px), (max-height: 615px) {
      .app {
        margin: 0;
        gap: 8px;
      }
      .side {
        width: 200px;
      }
      .panel {
        padding: 8px;
      }
      .title {
        font-size: 16px;
      }
      .stat {
        font-size: 18px;
      }
      button {
        padding: 8px;
        font-size: 14px;
      }
      .next-piece {
        grid-template-columns: repeat(4, 30px);
        grid-auto-rows: 30px;
        gap: 4px;
      }
    }
  </style>
</head>
<body oncontextmenu="return false;">
  <!-- Start Screen -->
  <div class="start-screen" id="startScreen">
    <div class="start-modal">
      <div class="start-description" data-i18n="game.description">
        Соединяйте одинаковые плитки, чтобы создавать большие значения. 
        Управляйте фигурами и создавайте комбо для получения дополнительных очков!
      </div>
      <button class="start-button" id="startButton" data-i18n="game.start">Начать игру</button>
    </div>
  </div>

  <!-- Pause Menu -->
  <div class="pause-menu" id="pauseMenu">
    <div class="pause-modal">
      <div class="pause-title" data-i18n="pause.title">ПАУЗА</div>
      <div class="pause-buttons">
        <button class="pause-button primary" id="resumeButton" data-i18n="pause.resume">Продолжить</button>
        <button class="pause-button" id="restartButton" data-i18n="pause.newGame">Новая игра</button>
        <button class="pause-button" id="soundButton" data-i18n="pause.sound">Звук: Вкл</button>
      </div>
    </div>
  </div>

  <!-- Leaderboard Modal -->
  <div class="overlay" id="leaderboardOverlay">
    <div class="leaderboard">
      <div class="leaderboard-title" data-i18n="leaderboard.title">Таблица лидеров</div>
      <div id="leaderboardContent" class="leaderboard-list">
        <div class="leaderboard-loading" data-i18n="leaderboard.loading">Загрузка...</div>
      </div>
      <button class="pause-button leaderboard-close" id="leaderboardClose" data-i18n="leaderboard.close">Закрыть</button>
    </div>
  </div>

  <!-- Ad Warning Notification -->
  <div class="ad-warning" id="adWarning">
    <div class="ad-warning-text" data-i18n="ad.warning">Реклама через</div>
    <div class="ad-warning-timer" id="adWarningTimer">2</div>
  </div>

  <div class="app">
    <div class="side">
      <div class="panel">
        <div class="stat"><span data-i18n="ui.score">Счёт</span>: <span id="score">0</span></div>
        <div class="stat"><span data-i18n="ui.best">Рекорд</span>: <span id="best">0</span></div>
        <div style="height:8px"></div>
        <button id="restart" data-i18n="ui.newGame">Новая игра</button>
        <button id="leaderboard" data-i18n="ui.leaderboard">Таблица лидеров</button>
      </div>
      <div class="panel">
        <div class="small" data-i18n="ui.nextPiece">Следующая фигура:</div>
        <div class="next-piece" id="nextPiece"></div>
      </div>
    </div>

    <div class="board-wrap">
      <button class="sound-toggle" id="soundToggle" >🔊</button>
      <button class="pause-toggle" id="pauseToggle" >⏸️</button>
      <div class="board" id="board" aria-label="Игровое поле">
        <div class="new-record" id="newRecord" data-i18n="game.newRecord">НОВЫЙ РЕКОРД!</div>
        <div class="first-place" id="firstPlace" data-i18n="game.firstPlace">ВЫ ЛУЧШИЙ ИГРОК!</div>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay"><div class="modal" id="modal"></div></div>

<script>
(() => {
  // CONFIG
  const COLS = 6;
  const ROWS = 12;
  const TICK_START = 700;
  const MIN_TICK = 100;
  const SETTLE_MS = 140;
  const AD_INTERVAL = 400000;
  const AD_WARNING_TIME = 2000;

  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const nextEl = document.getElementById('nextPiece');
  const overlay = document.getElementById('overlay');
  const modal = document.getElementById('modal');
  const newRecordEl = document.getElementById('newRecord');
  const firstPlaceEl = document.getElementById('firstPlace');
  const appEl = document.querySelector('.app');
  const soundToggleEl = document.getElementById('soundToggle');
  const pauseToggleEl = document.getElementById('pauseToggle');
  const startScreenEl = document.getElementById('startScreen');
  const startButtonEl = document.getElementById('startButton');
  const pauseMenuEl = document.getElementById('pauseMenu');
  const resumeButtonEl = document.getElementById('resumeButton');
  const restartButtonEl = document.getElementById('restartButton');
  const soundButtonEl = document.getElementById('soundButton');
  const leaderboardOverlayEl = document.getElementById('leaderboardOverlay');
  const leaderboardContentEl = document.getElementById('leaderboardContent');
  const leaderboardCloseEl = document.getElementById('leaderboardClose');
  const adWarningEl = document.getElementById('adWarning');
  const adWarningTimerEl = document.getElementById('adWarningTimer');

  let grid = [];
  let current = null;
  let nextPiece = null;
  let tick = TICK_START;
  let timer = null;
  let score = 0;
  let best = Number(localStorage.getItem('tetris2048_best') || 0);
  let paused = false;
  let settleTimer = null;
  let tileLayer = null;
  let newRecordShown = false;
  let newRecordSoundPlayed = false;
  let firstPlaceShown = false;
  let comboChain = 0;
  let justPlacedBlocks = [];
  let gameStarted = false;
  let currentBest = 0;
  let lastAdTime = 0;
  let playerName = "Игрок";
  let isAuthorized = false;
  let leaderboardData = [];
  let currentLanguage = 'ru';
  let leaderboardPaused = false;
  let secondChanceUsed = false;
  let pageVisible = true;
  let adTimer = null;
  let userInitiatedPause = false;
  let adWarningTimer = null;
  let adWarningActive = false;
  let dropSoundPending = false;
  let megaComboPlayed = false; // Флаг для отслеживания воспроизведения мегакомбо
  let audioSuspended = false; // Флаг для отслеживания состояния аудио
  let playerRank = null; // Ранг игрока в таблице лидеров

  // Yandex Games SDK variables
  let ysdk = null;
  let player = null;

  // Internationalization
  const translations = {
    ru: {
      game: {
        description: "Соединяйте одинаковые плитки, чтобы создавать большие значения. Управляйте фигурами и создавайте комбо для получения дополнительных очков!",
        start: "Начать игру",
        newRecord: "НОВЫЙ РЕКОРД!",
        firstPlace: "ВЫ ЛУЧШИЙ ИГРОК!",
        gameOver: "Конец игры",
        secondChance: "Второй шанс"
      },
      pause: {
        title: "ПАУЗА",
        resume: "Продолжить",
        newGame: "Новая игра",
        sound: "Звук: Вкл",
        soundoff: "Звук: Выкл",
        leaderboard: "Таблица лидеров"
      },
      ui: {
        score: "Счёт",
        best: "Рекорд",
        newGame: "Новая игра",
        leaderboard: "Таблица лидеров",
        nextPiece: "Следующая фигура:",
        playAgain: "Играть ещё",
        close: "Закрыть"
      },
      leaderboard: {
        title: "Таблица лидеров",
        loading: "Загрузка...",
        close: "Закрыть",
        empty: "Место не занято",
        yourPlace: "Ваше место"
      },
      praise: {
        bombastic: "БОМБЕЗНО!",
        amazing: "Потрясающе!",
        excellent: "Великолепно!",
        great: "Отлично!",
        good: "Хорошо!",
        super: "Супер!",
        comboMaster: "КОМБО-МАСТЕР!",
        classicCombo: "Классический комбо!",
        megaCombo: "МЕГА КОМБО!"
      },
      ad: {
        warning: "Реклама через"
      }
    },
    en: {
      game: {
        description: "Connect identical tiles to create larger values. Control shapes and create combos for extra points!",
        start: "Start Game",
        newRecord: "NEW RECORD!",
        firstPlace: "YOU ARE THE BEST PLAYER!",
        gameOver: "Game Over",
        secondChance: "Second Chance"
      },
      pause: {
        title: "PAUSE",
        resume: "Resume",
        newGame: "New Game",
        sound: "Sound: On",
        soundoff: "Sound: Off",
        leaderboard: "Leaderboard"
      },
      ui: {
        score: "Score",
        best: "Best",
        newGame: "New Game",
        leaderboard: "Leaderboard",
        nextPiece: "Next piece:",
        playAgain: "Play Again",
        close: "Close"
      },
      leaderboard: {
        title: "Leaderboard",
        loading: "Loading...",
        close: "Close",
        empty: "Position not taken",
        yourPlace: "Your position"
      },
      praise: {
        bombastic: "BOMBASTIC!",
        amazing: "Amazing!",
        excellent: "Excellent!",
        great: "Great!",
        good: "Good!",
        super: "Super!",
        comboMaster: "COMBO MASTER!",
        classicCombo: "Classic combo!",
        megaCombo: "MEGA COMBO!"
      },
      ad: {
        warning: "Ad in"
      }
    }
  };

  // Get current language
  function getCurrentLanguage() {
    if (ysdk && ysdk.environment && ysdk.environment.i18n) {
      return ysdk.environment.i18n.lang;
    }
    
    const browserLang = navigator.language || navigator.userLanguage;
    if (browserLang.startsWith('en')) return 'en';
    if (browserLang.startsWith('ru')) return 'ru';
    
    return 'ru';
  }

  // Translate text
  function t(key) {
    const keys = key.split('.');
    let value = translations[currentLanguage];
    
    for (const k of keys) {
      if (value && value[k]) {
        value = value[k];
      } else {
        value = translations.ru;
        for (const k of keys) {
          if (value && value[k]) {
            value = value[k];
          } else {
            return key;
          }
        }
        break;
      }
    }
    
    return value;
  }

  // Update all UI elements with translations
  function updateTranslations() {
    document.querySelectorAll('[data-i18n]').forEach(element => {
      const key = element.getAttribute('data-i18n');
      element.textContent = t(key);
    });
    
    soundButtonEl.textContent = (soundEnabled ? t('pause.sound') : t('pause.soundoff'));
  }

  bestEl.textContent = best;
  currentBest = best;

  // Initialize Yandex Games SDK
  function initYandexSDK() {
    return new Promise((resolve, reject) => {
      if (typeof YaGames !== 'undefined') {
        YaGames.init({
          scope: 'public_data'
        }).then(_ysdk => {
          ysdk = _ysdk;
          console.log('Yandex SDK initialized');
          
          currentLanguage = getCurrentLanguage();
          console.log('Language detected:', currentLanguage);
          
          updateTranslations();
          
          player = ysdk.getPlayer({
            scopes: 'public_data'
          }).then(_player => {
            player = _player;
            playerName = player.getName() || (currentLanguage === 'en' ? "Player" : "Игрок");
            isAuthorized = player.isAuthorized();
            console.log('Player info loaded:', playerName, isAuthorized);
            
            const env = ysdk.environment;
            console.log('Environment:', env);
            
            if (ysdk.features.LoadingAPI) {
              ysdk.features.LoadingAPI.ready();
              document.getElementById('startButton').style.opacity = 1;
            }
            
            resolve();
          }).catch(err => {
            console.error('Error getting player info:', err);
            
            const env = ysdk.environment;
            console.log('Environment:', env);
            
            if (ysdk.features.LoadingAPI) {
              ysdk.features.LoadingAPI.ready();
            }
            
            resolve();
          });
        }).catch(err => {
          console.error('Error initializing Yandex SDK:', err);
          reject(err);
        });
      } else {
        console.error('Yandex SDK not available');
        reject(new Error('Yandex SDK not available'));
      }
    });
  }

  // Show ad warning
  function showAdWarning(callback) {
    if (adWarningActive) return;
    
    adWarningActive = true;
    adWarningEl.classList.add('show');
    
    let countdown = 2;
    adWarningTimerEl.textContent = countdown;
    
    adWarningTimer = setInterval(() => {
      countdown--;
      adWarningTimerEl.textContent = countdown;
      
      if (countdown <= 0) {
        clearInterval(adWarningTimer);
        adWarningEl.classList.remove('show');
        adWarningActive = false;
        
        if (callback) callback();
      }
    }, 1000);
  }

  // Show ad
  function showAd(callback, isGameplayAd = false) {
    if (!ysdk) {
      if (callback) callback();
      return;
    }
    
    if (isGameplayAd) {
      const now = Date.now();
      if (now - lastAdTime < AD_INTERVAL) {
        if (callback) callback();
        return;
      }
    }
    
    if (!pageVisible) {
      if (callback) callback();
      return;
    }
    
    if (isGameplayAd) {
      lastAdTime = Date.now();
    }
    
    // Всегда останавливаем звук перед показом рекламы
    if (ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.stop();
    }
    
    if (timer) clearInterval(timer);
    suspendAudioSystem();
    
    if (isGameplayAd) {
      showAdWarning(() => {
        ysdk.adv.showFullscreenAdv({
          callbacks: {
            onClose: () => {
              console.log('Ad closed');
              // Всегда восстанавливаем звук после закрытия рекламы
              if (!paused && gameStarted) {
                if (ysdk.features.GameplayAPI) {
                  ysdk.features.GameplayAPI.start();
                }
                
                restartTimer();
                resumeAudioSystem();
              }
              if (callback) callback();
            },
            onError: (err) => {
              console.error('Ad error:', err);
              // Всегда восстанавливаем звук при ошибке рекламы
              if (!paused && gameStarted) {
                if (ysdk.features.GameplayAPI) {
                  ysdk.features.GameplayAPI.start();
                }
                
                restartTimer();
                resumeAudioSystem();
              }
              if (callback) callback();
            }
          }
        });
      });
    } else {
      ysdk.adv.showFullscreenAdv({
        callbacks: {
          onClose: () => {
            console.log('Ad closed');
            // Всегда восстанавливаем звук после закрытия рекламы
            if (!paused && gameStarted) {
              if (ysdk.features.GameplayAPI) {
                ysdk.features.GameplayAPI.start();
              }
              
              restartTimer();
              resumeAudioSystem();
            }
            if (callback) callback();
          },
          onError: (err) => {
            console.error('Ad error:', err);
            // Всегда восстанавливаем звук при ошибке рекламы
            if (!paused && gameStarted) {
              if (ysdk.features.GameplayAPI) {
                ysdk.features.GameplayAPI.start();
              }
              
              restartTimer();
              resumeAudioSystem();
            }
            if (callback) callback();
          }
        }
      });
    }
  }

  // Show rewarded ad
  function showRewardedAd(callback) {
    if (!ysdk) {
      if (callback) callback(false);
      return;
    }
    
    if (!pageVisible) {
      if (callback) callback(false);
      return;
    }
    
    // Всегда останавливаем звук перед показом рекламы
    if (ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.stop();
    }
    
    if (timer) clearInterval(timer);
    suspendAudioSystem();
    
    ysdk.adv.showRewardedVideo({
      callbacks: {
        onOpen: () => {
          console.log('Rewarded ad opened');
          // Дополнительно убеждаемся, что звук выключен при открытии рекламы
          suspendAudioSystem();
        },
        onRewarded: () => {
          console.log('Rewarded ad completed');
          if (callback) callback(true);
        },
        onClose: () => {
          console.log('Rewarded ad closed');
          // Всегда восстанавливаем звук после закрытия рекламы
          if (!paused && gameStarted) {
            if (ysdk.features.GameplayAPI) {
              ysdk.features.GameplayAPI.start();
            }
            
            restartTimer();
            resumeAudioSystem();
          }
          if (callback) callback(false);
        },
        onError: (err) => {
          console.error('Rewarded ad error:', err);
          // Всегда восстанавливаем звук при ошибке рекламы
          if (!paused && gameStarted) {
            if (ysdk.features.GameplayAPI) {
              ysdk.features.GameplayAPI.start();
            }
            
            restartTimer();
            resumeAudioSystem();
          }
          if (callback) callback(false);
        }
      }
    });
  }

  // Load leaderboard
  function loadLeaderboard() {
    if (!ysdk || !ysdk.leaderboards) {
      showEmptyLeaderboard();
      return Promise.resolve();
    }
    
    return ysdk.isAvailableMethod('leaderboards.getEntries').then(available => {
      if (!available) {
        console.log('Leaderboards methods not available for this user');
        showEmptyLeaderboard();
        return;
      }
      
      return Promise.all([
        ysdk.leaderboards.getEntries('leaders', {
          quantityTop: 10,
          includeUser: false
        }),
        ysdk.leaderboards.getPlayerEntry('leaders').catch(err => {
          if (err.code === 'LEADERBOARD_PLAYER_NOT_PRESENT') {
            return null;
          }
          throw err;
        })
      ]).then(([topEntries, playerEntry]) => {
        leaderboardData = topEntries.entries;
        playerRank = playerEntry ? playerEntry.rank : null;
        displayLeaderboard(leaderboardData, playerRank);
      }).catch(err => {
        console.error('Error getting leaderboard:', err);
        showEmptyLeaderboard();
      });
    }).catch(err => {
      console.log('Error checking leaderboard availability:', err);
      showEmptyLeaderboard();
    });
  }

  // Show empty leaderboard if SDK not available
  function showEmptyLeaderboard() {
    displayLeaderboard([]);
  }

  // Display leaderboard
  function displayLeaderboard(data, userRank) {
    if (!data || data.length === 0) {
      let html = '';
      for (let i = 1; i <= 10; i++) {
        html += `
          <div class="leaderboard-item">
            <div class="leaderboard-rank">${i}</div>
            <div class="leaderboard-name">${t('leaderboard.empty')}</div>
            <div class="leaderboard-score">-</div>
          </div>
        `;
      }
      
      if (best > 0) {
        html += `
          <div class="leaderboard-separator">${t('leaderboard.yourPlace')}</div>
          <div class="leaderboard-item current-player">
            <div class="leaderboard-rank">-</div>
            <div class="leaderboard-name">${playerName}</div>
            <div class="leaderboard-score">${best}</div>
          </div>
        `;
      }
      
      leaderboardContentEl.innerHTML = html;
      return;
    }
    
    let html = '';
    let playerInList = false;
    
    for (let i = 0; i < Math.min(10, data.length); i++) {
      const entry = data[i];
      const isCurrentPlayer = entry.player && entry.player.uniqueID === (player ? player.uniqueID : null);
      if (isCurrentPlayer) playerInList = true;
      
      html += `
        <div class="leaderboard-item ${isCurrentPlayer ? 'current-player' : ''}">
          <div class="leaderboard-rank">${entry.rank}</div>
          <div class="leaderboard-name">${entry.player ? entry.player.publicName : (currentLanguage === 'en' ? 'Anonymous' : 'Аноним')}</div>
          <div class="leaderboard-score">${entry.score}</div>
        </div>
      `;
    }
    
    for (let i = data.length; i < 10; i++) {
      html += `
        <div class="leaderboard-item">
          <div class="leaderboard-rank">${i + 1}</div>
          <div class="leaderboard-name">${t('leaderboard.empty')}</div>
          <div class="leaderboard-score">-</div>
        </div>
      `;
    }
    
    if (!playerInList && best > 0) {
      html += `
        <div class="leaderboard-separator">${t('leaderboard.yourPlace')}</div>
        <div class="leaderboard-item current-player">
          <div class="leaderboard-rank">${userRank ? userRank : '-'}</div>
          <div class="leaderboard-name">${playerName}</div>
          <div class="leaderboard-score">${best}</div>
        </div>
      `;
    }
    
    leaderboardContentEl.innerHTML = html;
  }

  // Submit score to leaderboard
  function submitScore(score) {
    if (!ysdk || !ysdk.leaderboards || score <= 0) {
      console.log('Leaderboards not available or invalid score');
      return Promise.resolve();
    }
    
    if (score > best) {
      best = score;
      bestEl.textContent = best;
      localStorage.setItem('tetris2048_best', best);
      
      if (player) {
        player.setData({ bestScore: best });
      }
      
      if (!newRecordSoundPlayed) {
        playSound('newrecord');
        newRecordSoundPlayed = true;
      }
    }
    
    return ysdk.isAvailableMethod('leaderboards.setScore').then(available => {
      if (!available) {
        console.log('Leaderboard setScore method not available for this user');
        return;
      }
      
      return ysdk.leaderboards.getPlayerEntry('leaders')
        .then(currentEntry => {
          if (!currentEntry || score >= currentEntry.score) {
            return ysdk.leaderboards.setScore('leaders', score);
          }
        })
        .then(() => {
          console.log('Score successfully updated in leaderboard:', score);
          
          // Проверяем, занял ли игрок первое место
          checkFirstPlace();
        })
        .catch(err => {
          if (err.code === 'LEADERBOARD_PLAYER_NOT_PRESENT') {
            console.log('Player not present in leaderboard, adding player...');
            return ysdk.leaderboards.setScore('leaders', score)
              .then(() => {
                console.log('Player added to leaderboard with score:', score);
                
                // Проверяем, занял ли игрок первое место
                checkFirstPlace();
              });
          } else if (err.code === 'LEADERBOARD_TOO_MANY_REQUESTS') {
            console.log('Too many requests, retrying in 1 second');
            setTimeout(() => submitScore(score), 1000);
          } else if (err.code === 'NETWORK_ERROR') {
            console.log('Network error, retrying in 2 seconds');
            setTimeout(() => submitScore(score), 2000);
          } else {
            console.error('Error updating leaderboard score:', err);
          }
        });
    }).catch(err => {
      console.log('Error checking leaderboard availability:', err);
    });
  }
  
  // Проверка, занял ли игрок первое место
  function checkFirstPlace() {
    if (!ysdk || !ysdk.leaderboards) {
      return;
    }
    
    return ysdk.leaderboards.getPlayerEntry('leaders')
      .then(playerEntry => {
        if (playerEntry && playerEntry.rank === 1 && !firstPlaceShown) {
          showFirstPlace();
          firstPlaceShown = true;
        }
      })
      .catch(err => {
        console.error('Error checking player rank:', err);
      });
  }
  
  // Показать уведомление о первом месте
  function showFirstPlace() {
    if (firstPlaceShown) return;
    firstPlaceShown = true;
    
    if (!newRecordSoundPlayed) {
      playSound('newrecord');
      newRecordSoundPlayed = true;
    }
    
    const firstPlaceEl = document.getElementById('firstPlace');
    firstPlaceEl.classList.add('show');
    setTimeout(() => {
      firstPlaceEl.classList.remove('show');
    }, 3000);
  }

  // Responsive scaling function
  function updateScale() {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    const normalWidth = 620;
    const normalHeight = 615;
    const largeWidth = 1000;
    const largeHeight = 650;
    const minSize = 320;
    
    let scale;
    
    if (windowWidth < normalWidth || windowHeight < normalHeight) {
      const scaleX = Math.max(minSize / normalWidth, windowWidth / normalWidth);
      const scaleY = Math.max(minSize / normalHeight, windowHeight / normalHeight);
      scale = Math.min(scaleX, scaleY);
    } else if (windowWidth >= largeWidth && windowHeight >= largeHeight) {
      const scaleX = windowWidth / largeWidth;
      const scaleY = windowHeight / largeHeight;
      scale = Math.min(scaleX, scaleY);
    } else {
      scale = 1;
    }
    
    document.documentElement.style.setProperty('--scale', scale);
  }

  // Initial scale calculation
  updateScale();
  
  // Update scale on window resize
  window.addEventListener('resize', updateScale);

  // WebAudio API Sound System
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  const sounds = {};
  let soundEnabled = true;
  let bgMusicSource = null;
  let bgMusicGainNode = null;
  
  // Загрузка звуков
  function loadSounds() {
    sounds.move = () => {};
    sounds.rotate = () => {};
    sounds.drop = () => {};
    sounds.merge = () => {};
    sounds.combo = () => {};
    sounds.megacombo = () => {};
    sounds.gameover = () => {};
    sounds.newrecord = () => {};
    sounds.background = () => {};

    loadSound('move.mp3').then(sound => { if (sound) sounds.move = sound; });
    loadSound('rotate.mp3').then(sound => { if (sound) sounds.rotate = sound; });
    loadSound('drop.mp3').then(sound => { if (sound) sounds.drop = sound; });
    loadSound('merge.mp3').then(sound => { if (sound) sounds.merge = sound; });
    loadSound('combo.mp3').then(sound => { if (sound) sounds.combo = sound; });
    loadSound('megacombo.mp3').then(sound => { if (sound) sounds.megacombo = sound; });
    loadSound('gameover.mp3').then(sound => { if (sound) sounds.gameover = sound; });
    loadSound('newrecord.mp3').then(sound => { if (sound) sounds.newrecord = sound; });
    loadSoundBuffer('background.mp3').then(buffer => { if (buffer) sounds.backgroundBuffer = buffer; });
  }
  
  // Функция для загрузки звука и возврата функции-воспроизведения
  function loadSound(url) {
    return fetch(url)
      .then(response => {
        if (!response.ok) throw new Error('not found');
        return response.arrayBuffer();
      })
      .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
      .then(audioBuffer => {
        return () => {
          if (!soundEnabled || audioSuspended) return;
          if (audioContext.state === 'suspended') return;
          
          const source = audioContext.createBufferSource();
          source.buffer = audioBuffer;
          
          const gainNode = audioContext.createGain();
          gainNode.gain.value = 0.7;
          
          source.connect(gainNode);
          gainNode.connect(audioContext.destination);
          source.start();
        };
      })
      .catch(error => {
        console.warn('Error loading sound:', url, error);
        return null;
      });
  }

  // load background buffer for looped playback
  function loadSoundBuffer(url){
    return fetch(url)
      .then(response => {
        if (!response.ok) throw new Error('not found');
        return response.arrayBuffer();
      })
      .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
      .catch(err => { console.warn('bg load err', err); return null; });
  }

  // Воспроизведение звука
  function playSound(soundName) {
    if (!soundEnabled || audioSuspended) return;
    if (audioContext.state === 'suspended') return;
    if (sounds[soundName]) {
      try { sounds[soundName](); } catch(e){ /* ignore */ }
    }
  }
  
  // Воспроизведение фоновой музыки в цикле
  function playBackgroundMusic() {
    if (!soundEnabled || audioSuspended) return;
    if (audioContext.state === 'suspended') return;
    stopBackgroundMusic();
    if (!sounds.backgroundBuffer) {
      loadSoundBuffer('background.mp3').then(buffer => {
        if (!buffer) return;
        sounds.backgroundBuffer = buffer;
        _startBgFromBuffer(buffer);
      }).catch(()=>{});
      return;
    }
    _startBgFromBuffer(sounds.backgroundBuffer);
  }
  function _startBgFromBuffer(buffer){
    try {
      bgMusicSource = audioContext.createBufferSource();
      bgMusicSource.buffer = buffer;
      bgMusicSource.loop = true;
      bgMusicGainNode = audioContext.createGain();
      bgMusicGainNode.gain.value = 0.3;
      bgMusicSource.connect(bgMusicGainNode);
      bgMusicGainNode.connect(audioContext.destination);
      bgMusicSource.start(0);
    } catch(e){
      console.warn('bg start error', e);
    }
  }
  
  // Остановка фоновой музыки
  function stopBackgroundMusic() {
    if (bgMusicSource) {
      try { bgMusicSource.stop(); } catch(e) {}
      bgMusicSource = null;
    }
    if (bgMusicGainNode) {
      try { bgMusicGainNode.disconnect(); } catch(e) {}
      bgMusicGainNode = null;
    }
  }
  
  // Переключение звука (UI-кнопка)
  function toggleSound() {
    soundEnabled = !soundEnabled;
    soundToggleEl.textContent = soundEnabled ? '🔊' : '🔇';
    soundToggleEl.classList.toggle('muted', !soundEnabled);
    soundButtonEl.textContent =  (soundEnabled ? t('pause.sound') : t('pause.soundoff'));
    
    if (soundEnabled) {
      if (audioContext.state === 'suspended') {
        audioContext.resume().then(()=>{
          if (!paused && gameStarted && !audioSuspended) playBackgroundMusic();
        });
      } else {
        if (!paused && gameStarted && !audioSuspended) playBackgroundMusic();
      }
    } else {
      stopBackgroundMusic();
    }
  }
  
  // Остановить всё аудио (используется при паузе)
  function suspendAudioSystem() {
    audioSuspended = true;
    stopBackgroundMusic();
    if (audioContext && audioContext.state === 'running') {
      audioContext.suspend().catch((err) => {
        console.warn('Error suspending audio context:', err);
      });
    }
  }
  
  // Восстановить аудио после паузы
  function resumeAudioSystem() {
    audioSuspended = false;
    if (audioContext && audioContext.state === 'suspended') {
      audioContext.resume().then(()=>{
        if (soundEnabled && gameStarted && !paused) {
          playBackgroundMusic();
        }
      }).catch((err) => {
        console.warn('Error resuming audio context:', err);
      });
    } else {
      if (soundEnabled && gameStarted && !paused) {
        playBackgroundMusic();
      }
    }
  }

  // Обработчик кнопки переключения звука
  soundToggleEl.addEventListener('click', toggleSound);
  
  // Инициализация звуковой системы
  loadSounds();

  // shapes
  const SHAPES = {
    I: [[0,1],[1,1],[2,1],[3,1]],
    O: [[0,0],[1,0],[0,1],[1,1]],
    T: [[0,1],[1,1],[2,1],[1,0]],
    L: [[0,0],[0,1],[0,2],[1,2]],
    J: [[1,0],[1,1],[1,2],[0,2]],
    S: [[0,1],[1,1],[1,0],[2,0]],
    Z: [[0,0],[1,0],[1,1],[2,1]]
  };
  const SHAPE_KEYS = Object.keys(SHAPES);

  // DOM helpers: grid background cells
  function createBoard(){
    boardEl.style.setProperty('--cols', COLS);
    boardEl.style.setProperty('--rows', ROWS);
    boardEl.innerHTML = `<div class="new-record" id="newRecord">${t('game.newRecord')}</div><div class="first-place" id="firstPlace">${t('game.firstPlace')}</div>`;
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const bg = document.createElement('div');
        bg.className = 'cell-bg';
        bg.dataset.r = r; bg.dataset.c = c;
        boardEl.appendChild(bg);
      }
    }
    if (!tileLayer){
      tileLayer = document.createElement('div');
      tileLayer.style.position = 'absolute';
      tileLayer.style.inset = '12px';
      tileLayer.style.pointerEvents = 'none';
    }
    tileLayer.innerHTML = '';
    boardEl.appendChild(tileLayer);
  }

  function resetGrid(){ grid = Array.from({length:ROWS},()=>Array(COLS).fill(0)); }

  function randInitialValue(){ const r = Math.random(); if (r<0.7) return 2; if (r<0.95) return 4; return 8; }

  function makePiece(shapeKey=null){
    const key = shapeKey || SHAPE_KEYS[Math.floor(Math.random()*SHAPE_KEYS.length)];
    const blocks = SHAPES[key].map(p=>({x:p[0], y:p[1], v: randInitialValue()}));
    const minX = Math.min(...blocks.map(b=>b.x));
    const maxX = Math.max(...blocks.map(b=>b.x));
    const width = maxX-minX+1;
    const offsetX = Math.floor((COLS-width)/2) - minX;
    const offsetY = -Math.max(...blocks.map(b=>b.y)) - 1;
    return {blocks, x:offsetX, y:offsetY, key};
  }

  function cellMetrics(){
    const style = getComputedStyle(document.documentElement);
    const cell = parseFloat(style.getPropertyValue('--cell-size')) ;
    const gap = parseFloat(style.getPropertyValue('--gap'));
    const padding = 12;
    return {cell, gap, padding};
  }

  // Manage tile elements by id key 'r-c' for grid, and 'cur-i' for current moving
  function ensureTile(id, val){
    if (!tileLayer) return null;
    let el = tileLayer.querySelector(`[data-id='${id}']`);
    if (!el){
      el = document.createElement('div');
      el.className = 'tile-el';
      el.setAttribute('data-id', id);
      el.innerHTML = `<div class='label'></div>`;
      tileLayer.appendChild(el);
    }
    el.setAttribute('data-val', val);
    el.querySelector('.label').textContent = val;
    return el;
  }

  function removeTile(id){ if (!tileLayer) return; const el = tileLayer.querySelector(`[data-id='${id}']`); if (el) el.remove(); }

  // Draw function: update tiles to reflect grid + current piece
  function draw(){
    const {cell,gap,padding} = cellMetrics();
    const tileIds = new Set();

    if (!tileLayer) return;

    // draw grid
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
      const v = grid[r][c];
      const id = `g-${r}-${c}`;
      if (v){
        const el = ensureTile(id, v);
        if (!el) continue;
        tileIds.add(id);
        const left = c*(cell+gap);
        const top = r*(cell+gap);
        el.style.left = `${left}px`;
        el.style.top = `${top}px`;
        el.style.width = `${cell}px`;
        el.style.height = `${cell}px`;
      } else {
        removeTile(id);
      }
    }

    // draw current piece
    if (current){
      current.blocks.forEach((b, idx)=>{
        const r = current.y + b.y;
        const c = current.x + b.x;
        const id = `cur-${idx}`;
        const val = b.v;
        const el = ensureTile(id, val);
        if (!el) return;
        tileIds.add(id);
        const left = c*(cell+gap);
        const top = r*(cell+gap);
        el.style.left = `${left}px`;
        el.style.top = `${top}px`;
        el.style.width = `${cell}px`;
        el.style.height = `${cell}px`;
      });
    } else {
      tileLayer.querySelectorAll('[data-id^="cur-"]').forEach(e=>e.remove());
    }

    // cleanup orphan tiles
    tileLayer.querySelectorAll('[data-id]').forEach(el=>{
      const id = el.getAttribute('data-id');
      if (!tileIds.has(id)) el.remove();
    });
  }

  // Next preview (simple grid cells)
  function drawNext(){
    nextEl.innerHTML = '';
    for (let i=0;i<16;i++){ 
      const d = document.createElement('div'); 
      d.className='cell-bg'; 
      nextEl.appendChild(d);
    }    
    if (!nextPiece) return;
    
    const xs = nextPiece.blocks.map(b => b.x);
    const ys = nextPiece.blocks.map(b => b.y);
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    const width = maxX - minX + 1;
    const height = maxY - minY + 1;
    
    const offsetX = Math.floor((4 - width) / 2) - minX;
    const offsetY = Math.floor((4 - height) / 2) - minY;
    
    nextPiece.blocks.forEach(b => {
      const r = b.y + offsetY;
      const c = b.x + offsetX;
      const idx = r * 4 + c;
      if (idx >= 0 && idx < nextEl.children.length){
        const el = nextEl.children[idx];
        el.className = '';
        el.style.borderRadius='8px';
        el.textContent = b.v; 
        el.style.fontWeight = 800; 
        el.style.display='flex'; 
        el.style.alignItems='center'; 
        el.style.justifyContent='center';
        el.style.background = "#f1efe9";
        el.style.color = "black";
      }
    });
  }

  function collides(x,y,blocks){
    for (const b of blocks){
      const r = y + b.y;
      const c = x + b.x;
      if (c<0 || c>=COLS) return true;
      if (r>=ROWS) return true;
      if (r>=0 && grid[r][c]) return true;
    }
    return false;
  }

  function move(dx, dy, playMoveSound = false){
    if (!current) return false;
    if (!collides(current.x + dx, current.y + dy, current.blocks)){
      current.x += dx; current.y += dy; 
      if (playMoveSound) {
        playSound('move');
      }
      draw(); 
      return true;
    }
    return false;
  }

  function rotate(){
    if (!current) return;
    const newBlocks = current.blocks.map(b=>({x: b.y, y: -b.x, v: b.v}));
    const minX = Math.min(...newBlocks.map(b=>b.x));
    const minY = Math.min(...newBlocks.map(b=>b.y));
    newBlocks.forEach(b=>{ b.x -= minX; b.y -= minY; });
    if (!collides(current.x, current.y, newBlocks)){
      current.blocks = newBlocks; 
      playSound('rotate');
      draw();
    } else {
      if (!collides(current.x-1, current.y, newBlocks)) { current.x -=1; current.blocks=newBlocks; draw(); }
      else if (!collides(current.x+1, current.y, newBlocks)) { current.x +=1; current.blocks=newBlocks; draw(); }
    }
  }

  function hardDrop(){
    if (!current) return;
    
    let finalY = current.y;
    while (!collides(current.x, finalY + 1, current.blocks)) {
      finalY++;
    }
    
    const distance = finalY - current.y;
    
    if (distance > 0) {
      current.blocks.forEach((b, idx) => {
        const id = `cur-${idx}`;
        const el = tileLayer.querySelector(`[data-id='${id}']`);
        if (el) {
          el.classList.add('falling');
        }
      });
      
      current.y = finalY;
      draw();
      
      setTimeout(() => {
        playSound('drop');
      }, 100);
      
      setTimeout(() => {
        current.blocks.forEach((b, idx) => {
          const id = `cur-${idx}`;
          const el = tileLayer.querySelector(`[data-id='${id}']`);
          if (el) {
            el.classList.remove('falling');
          }
        });
        
        lockPiece();
      }, 250);
    } else {
      lockPiece();
    }
  }

  // Новая функция для проверки горизонтальных слияний
  function checkHorizontalMerges(placedBlocks) {
    const mergedCells = [];
    const processed = new Set();
    
    for (const [r, c] of placedBlocks) {
      const key = `${r},${c}`;
      if (processed.has(key)) continue;
      
      const val = grid[r][c];
      if (!val) continue;
      
      const component = [];
      const queue = [[r, c]];
      processed.add(key);
      
      while (queue.length > 0) {
        const [cr, cc] = queue.shift();
        component.push([cr, cc]);
        
        const left = cc - 1;
        const right = cc + 1;
        
        if (left >= 0 && grid[cr][left] === val && !processed.has(`${cr},${left}`)) {
          processed.add(`${cr},${left}`);
          queue.push([cr, left]);
        }
        
        if (right < COLS && grid[cr][right] === val && !processed.has(`${cr},${right}`)) {
          processed.add(`${cr},${right}`);
          queue.push([cr, right]);
        }
      }
      
      // Обрабатываем компоненты с 2 или более плитками
      if (component.length >= 2) {
        let mergeCount = component.length;
        
        // Если количество плиток нечетное, объединяем только (component.length - 1) плиток
        if (component.length % 2 !== 0) {
          mergeCount = component.length - 1;
        }
        
        if (mergeCount >= 2) {
          mergedCells.push(component.slice(0, mergeCount));
        }
      }
    }
    
    return mergedCells;
  }

  // Новая функция для выполнения горизонтальных слияний
  function performHorizontalMerges(mergedComponents) {
    const anims = [];
    
    for (const component of mergedComponents) {
      if (component.length < 2) continue;
      
      const val = grid[component[0][0]][component[0][1]];
      
      // ИСПРАВЛЕНО: новая формула для слияния
      const mergedVal = val * component.length;
      
      // Находим ячейку, которая была на поле до падения фигуры
      let targetCell = null;
      for (const [r, c] of component) {
        const wasPlaced = justPlacedBlocks.some(([pr, pc]) => pr === r && pc === c);
        if (!wasPlaced) {
          targetCell = [r, c];
          break;
        }
      }
      
      // Если все ячейки из упавшей фигуры, выбираем центральную
      if (!targetCell) {
        // Для горизонтального слияния выбираем центральную ячейку
        component.sort((a, b) => a[1] - b[1]); // Сортируем по колонке
        const centerIndex = Math.floor(component.length / 2);
        targetCell = component[centerIndex];
      }
      
      const [mr, mc] = targetCell;
      
      for (const [r, c] of component) {
        grid[r][c] = 0;
      }
      
      grid[mr][mc] = mergedVal;
      
      const comboMultiplier = 1 + Math.min(0.5, comboChain * 0.083);
      score += Math.floor(mergedVal * comboMultiplier);
      updateScoreAndLevel();
      
      anims.push({r: mr, c: mc, val: mergedVal, size: component.length});
      playSound('merge');
    }
    
    return anims;
  }

  // Новая механика слияния
  function processMerges(limitSet = null){
    let anyMerged = false;
    const anims = [];
    const visited = Array.from({length:ROWS},()=>Array(COLS).fill(false));
    
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]]; // Сначала вертикальные направления

    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (visited[r][c] || !grid[r][c]) continue;
        
        const val = grid[r][c];
        const component = [];
        const queue = [[r,c]];
        visited[r][c] = true;
        while(queue.length){
          const [cr, cc] = queue.shift();
          component.push([cr, cc]);
          for (const [dr, dc] of dirs){
            const nr = cr + dr; const nc = cc + dc;
            if (nr<0||nr>=ROWS||nc<0||nc>=COLS) continue;
            if (visited[nr][nc] || grid[nr][nc] !== val) continue;
            visited[nr][nc] = true;
            queue.push([nr, nc]);
          }
        }

        if (limitSet){
          let intersects = false;
          for (const [cr,cc] of component){
            if (limitSet.has(`${cr},${cc}`)){ intersects = true; break; }
          }
          if (!intersects) continue;
        }

        // Обрабатываем компоненты с 2 или более плитками
        if (component.length >= 2){
          anyMerged = true;

          let mergeCount = component.length;
          
          // Если количество плиток нечетное, объединяем только (component.length - 1) плиток
          if (component.length % 2 !== 0) {
            mergeCount = component.length - 1;
          }

          // ИСПРАВЛЕНО: новая формула для слияния
          const mergedVal = val * mergeCount;

          // Находим ячейку, которая была на поле до падения фигуры
          let targetCell = null;
          for (const [r, c] of component) {
            const wasPlaced = justPlacedBlocks.some(([pr, pc]) => pr === r && pc === c);
            if (!wasPlaced) {
              targetCell = [r, c];
              break;
            }
          }
          
          // Если все ячейки из упавшей фигуры, выбираем целевую ячейку
          if (!targetCell) {
            // Для слияния двух плиток выбираем нижнюю ячейку
            if (mergeCount === 2) {
              component.sort((a, b) => b[0] - a[0]); // Сортируем по убыванию строки
              targetCell = component[0]; // Берем самую нижнюю
            } else {
              // Для других случаев выбираем самую нижнюю ячейку
              component.sort((a, b) => b[0] - a[0]); // Сортируем по убыванию строки
              
              // Если есть несколько ячеек в одной строке, выбираем центральную по колонке
              const bottomRow = component[0][0];
              const bottomRowCells = component.filter(cell => cell[0] === bottomRow);
              
              if (bottomRowCells.length > 1) {
                bottomRowCells.sort((a, b) => a[1] - b[1]); // Сортируем по колонке
                const centerIndex = Math.floor(bottomRowCells.length / 2);
                targetCell = bottomRowCells[centerIndex];
              } else {
                targetCell = component[0];
              }
            }
          }
          
          const [mr, mc] = targetCell;

          // Очищаем только те ячейки, которые участвуют в слиянии
          const cellsToMerge = component.slice(0, mergeCount);
          for (const [cr, cc] of cellsToMerge) {
            grid[cr][cc] = 0;
          }

          grid[mr][mc] = mergedVal;

          const comboMultiplier = 1 + Math.min(0.5, comboChain * 0.083);
          score += Math.floor(mergedVal * comboMultiplier);
          updateScoreAndLevel();

          anims.push({r: mr, c: mc, val: mergedVal, size: mergeCount});
          playSound('merge');
        }
      }
    }

    return {anyMerged, anims};
  }

  // ИСПРАВЛЕННАЯ функция applyGravity с анимацией
  function applyGravity(){
    return new Promise((resolve) => {
      const {cell,gap} = cellMetrics();
      const movedTiles = [];
      let moved = false;
      
      for (let c=0;c<COLS;c++){
        let write = ROWS-1;
        for (let r=ROWS-1;r>=0;r--){
          if (grid[r][c]){
            if (r !== write){ 
              movedTiles.push({
                from: {r, c},
                to: {r: write, c},
                val: grid[r][c]
              });
              grid[write][c] = grid[r][c]; 
              grid[r][c] = 0; 
              moved = true;
            }
            write--;
          }
        }
      }
      
      if (moved && movedTiles.length > 0) {
        movedTiles.forEach(tile => {
          const id = `g-${tile.from.r}-${tile.from.c}`;
          const el = tileLayer.querySelector(`[data-id='${id}']`);
          if (el) {
            el.classList.add('falling');
            const left = tile.to.c*(cell+gap);
            const top = tile.to.r*(cell+gap);
            el.style.left = `${left}px`;
            el.style.top = `${top}px`;
            
            el.setAttribute('data-id', `g-${tile.to.r}-${tile.to.c}`);
          }
        });
        
        setTimeout(() => {
          playSound('drop');
        }, 100);
        
        setTimeout(() => {
          movedTiles.forEach(tile => {
            const id = `g-${tile.to.r}-${tile.to.c}`;
            const el = tileLayer.querySelector(`[data-id='${id}']`);
            if (el) {
              el.classList.remove('falling');
            }
          });
          resolve(moved);
        }, 250);
      } else {
        resolve(moved);
      }
    });
  }

  // animate merges: pop, spawn particles, show praise
  function animateMerges(anims){
    if (!anims || anims.length===0) return;
    const {cell,gap} = cellMetrics();
    for (const a of anims){
      const id = `g-${a.r}-${a.c}`;
      const el = tileLayer.querySelector(`[data-id='${id}']`);
      if (el){
        el.classList.add('merge-anim');
        setTimeout(()=>el.classList.remove('merge-anim'), 520);
      }
      const originLeft = a.c*(cell+gap) + cell/2;
      const originTop = a.r*(cell+gap) + cell/2;
      spawnParticles(originLeft, originTop, Math.min(12, 3 + Math.floor(a.size/2)));
      const praise = choosePraise(a.val, a.size);
      showPraise(praise, originLeft, originTop);
    }
  }

  function spawnParticles(x,y,count){
    for (let i=0;i<count;i++){
      const p = document.createElement('div');
      p.className = 'particle';
      p.style.left = `${x - 5}px`;
      p.style.top = `${y - 5}px`;
      const angle = (Math.random()*Math.PI*2);
      const dist = 40 + Math.random()*40;
      const dx = Math.cos(angle)*dist + 'px';
      const dy = Math.sin(angle)*dist - 20 + 'px';
      p.style.setProperty('--dx', dx);
      p.style.setProperty('--dy', dy);
      const dur = 700 + Math.random()*300;
      p.style.animation = `starFly ${dur}ms cubic-bezier(.2,.9,.2,1) forwards`;
      tileLayer.appendChild(p);
      setTimeout(()=>{ p.remove(); }, dur + 50);
    }
  }

  function choosePraise(val, size){
    if (val >= 1024) return t('praise.bombastic');
    if (val >= 512) return t('praise.amazing');
    if (val >= 128) return t('praise.excellent');
    if (size >= 4) return t('praise.great');
    if (size >= 2) return t('praise.good');
    return t('praise.super');
  }

  function showPraise(text, x, y){
    const p = document.createElement('div');
    p.className = 'praise';
    p.textContent = text;
    p.style.left = `${x}px`;
    p.style.top = `${y}px`;
    tileLayer.appendChild(p);
    requestAnimationFrame(()=>{ p.classList.add('show'); });
    setTimeout(()=>{ p.classList.remove('show'); setTimeout(()=>p.remove(),500); }, 1200);
  }

  function showCombo(count, x, y){
    if (count <= 1) return;
    
    // Воспроизводим обычный звук комбо для всех комбо
    playSound('combo');
    
    const p = document.createElement('div');
    p.className = 'combo';
    p.textContent = `COMBO x${count}`;
    p.style.left = `${x}px`;
    p.style.top = `${y - 20}px`;
    tileLayer.appendChild(p);
    requestAnimationFrame(()=>{ p.classList.add('show'); });
    setTimeout(()=>{ p.classList.remove('show'); setTimeout(()=>p.remove(),400); }, 1000);
    
    // Добавляем бонусные очки за комбо x2 и выше
    let bonusPoints = 0;
    if (count === 2) bonusPoints = 40;
    else if (count === 3) bonusPoints = 80;
    else if (count === 4) bonusPoints = 160;
    else if (count === 5) bonusPoints = 300;
    else if (count >= 6) bonusPoints = 500;
    
    if (bonusPoints > 0) {
      score += bonusPoints;
      updateScoreAndLevel();
      
      // Показываем бонус
      const bonus = document.createElement('div');
      bonus.className = 'combo-bonus';
      bonus.textContent = `+${bonusPoints}`;
      bonus.style.left = `${x}px`;
      bonus.style.top = `${y - 50}px`;
      tileLayer.appendChild(bonus);
      requestAnimationFrame(()=>{ bonus.classList.add('show'); });
      setTimeout(()=>{ bonus.classList.remove('show'); setTimeout(()=>bonus.remove(),400); }, 1000);
    }
  }

  function showNewRecord() {
    if (newRecordShown) return;
    newRecordShown = true;
    
    if (!newRecordSoundPlayed) {
      playSound('newrecord');
      newRecordSoundPlayed = true;
    }
    
    const newRecordEl = document.getElementById('newRecord');
    newRecordEl.classList.add('show');
    setTimeout(() => {
      newRecordEl.classList.remove('show');
    }, 3000);
  }

  // ИСПРАВЛЕННАЯ ЛОГИКА: единая функция для выполнения всех возможных слияний
  function performAllMerges() {
    function resolveBoard() {
      const mergeResult = processMerges();

      if (mergeResult.anyMerged) {
        comboChain++;
        draw();
        animateMerges(mergeResult.anims);

        if (mergeResult.anims.length > 0) {
          const a = mergeResult.anims[0];
          const {cell,gap} = cellMetrics();
          const originLeft = a.c*(cell+gap) + cell/2;
          const originTop = a.r*(cell+gap) + cell/2;
          showCombo(comboChain, originLeft, originTop);
        }

        setTimeout(() => {
          applyGravity().then(() => {
            setTimeout(resolveBoard, 300);
          });
        }, 500);

      } else {
        // ВОСПРОИЗВОДИМ МЕГАКОМБО ТОЛЬКО ЗДЕСЬ, КОГДА ЦЕПОЧКА ЗАВЕРШИЛАСЬ
        if (comboChain >= 4 && !megaComboPlayed) {
          playSound('megacombo');
          megaComboPlayed = true;
          
          const centerX = (COLS/2) * (cellMetrics().cell + cellMetrics().gap);
          const centerY = (ROWS/3) * (cellMetrics().cell + cellMetrics().gap);
          showPraise(t('praise.comboMaster'), centerX, centerY);
        } else if (comboChain > 1) {
          const centerX = (COLS/2) * (cellMetrics().cell + cellMetrics().gap);
          const centerY = (ROWS/3) * (cellMetrics().cell + cellMetrics().gap);
          showPraise(t('praise.classicCombo'), centerX, centerY);
        }
        
        // Сбрасываем флаг мегакомбо при завершении хода
        megaComboPlayed = false;
        
        spawnNext();
      }
    }

    resolveBoard();
  }

  // lockPiece: при блокировке выполняем приоритетные боковые слияния вокруг только что упавших блоков
  function lockPiece(){
    if (!current) return;
    
    justPlacedBlocks = [];
    
    for (const b of current.blocks){
      const r = current.y + b.y; 
      const c = current.x + b.x;
      if (r<0) { return gameOver(); }
      grid[r][c] = b.v;
      justPlacedBlocks.push([r, c]);
    }

    current = null;
    comboChain = 0;

    // Сбрасываем флаг мегакомбо при начале нового хода
    megaComboPlayed = false;

    // ИСПРАВЛЕНИЕ: Всегда вызываем draw() после размещения фигуры
    draw();

    const horizontalMerges = checkHorizontalMerges(justPlacedBlocks);
    let horizontalMergeAnims = [];
    
    if (horizontalMerges.length > 0) {
      comboChain = 1; 
      horizontalMergeAnims = performHorizontalMerges(horizontalMerges);
      draw();
      animateMerges(horizontalMergeAnims);
      
      if (horizontalMergeAnims.length > 0) {
        const a = horizontalMergeAnims[0];
        const {cell,gap} = cellMetrics();
        const originLeft = a.c*(cell+gap) + cell/2;
        const originTop = a.r*(cell+gap) + cell/2;
        showCombo(comboChain, originLeft, originTop);
      }
      
      setTimeout(() => {
        applyGravity().then(() => {
          setTimeout(() => {
            performAllMerges();
          }, 300);
        });
      }, 300);
    } else {
      // ИСПРАВЛЕНИЕ: Всегда применяем гравитацию с анимацией, даже если нет слияний
      applyGravity().then((moved) => {
        // Если были перемещения плиток, ждем завершения анимации
        if (moved) {
          setTimeout(() => {
            performAllMerges();
          }, 500);
        } else {
          // Если перемещений не было, сразу переходим к следующему шагу
          performAllMerges();
        }
      });
    }
  }

  function spawnNext(){
    if (!nextPiece) nextPiece = makePiece();
    current = {blocks: nextPiece.blocks.map(b=>({x:b.x,y:b.y,v:b.v})), x: nextPiece.x, y: nextPiece.y, key: nextPiece.key};
    nextPiece = makePiece();
    drawNext();
    draw();
    comboChain = 0;
    if (collides(current.x, current.y, current.blocks)){
      gameOver();
    }
  }

  function updateScoreAndLevel(){
    scoreEl.textContent = score;
    restartTimer();
    if (score > best){ 
      best = score; 
      bestEl.textContent = best; 
      localStorage.setItem('tetris2048_best', best); 
      if (score > currentBest) {
        showNewRecord();
        currentBest = score;
      }
    }
  }

  function step(){
    if (paused || leaderboardPaused) return;
    if (!current) return;
    if (move(0,1, false)){
      if (settleTimer){ clearTimeout(settleTimer); settleTimer = null; dropSoundPending = false; }
      draw();
    } else {
      if (!settleTimer){
        if (!dropSoundPending){
          setTimeout(() => {
            playSound('drop');
          }, 150);
          dropSoundPending = true;
        }
        settleTimer = setTimeout(()=>{ 
          settleTimer = null; 
          dropSoundPending = false;
          lockPiece(); 
        }, SETTLE_MS);
      }
    }
  }

  function restartTimer(){ 
    if (timer) clearInterval(timer); 
    timer = setInterval(step, tick); 
  }

  function startGame(){ 
    resetGrid(); 
    createBoard(); 
    draw(); 
    score = 0; 
    tick = TICK_START; 
    paused = false; 
    leaderboardPaused = false;
    userInitiatedPause = false;
    current = null; 
    nextPiece = null; 
    justPlacedBlocks = [];
    newRecordShown = false;
    newRecordSoundPlayed = false;
    firstPlaceShown = false;
    comboChain = 0;
    currentBest = best;
    secondChanceUsed = false;
    lastAdTime = Date.now();
    
    // Сбрасываем флаг мегакомбо при начале новой игры
    megaComboPlayed = false;
    
    spawnNext(); 
    scoreEl.textContent='0'; 
    restartTimer(); 
    overlay.classList.remove('show'); 
    gameStarted = true;
    
    if (ysdk && ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.start();
    }
    
    if (soundEnabled) {
      resumeAudioSystem();
    }
  }

  // Функция для использования второго шанса
  function useSecondChance() {
    if (secondChanceUsed) return;
    
    showRewardedAd((success) => {
      if (success) {
        secondChanceUsed = true;
        
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (grid[r][c] && grid[r][c] < 16) {
              grid[r][c] = 0;
            }
          }
        }
        
        applyGravity().then(() => {
          draw();
          overlay.classList.remove('show');
          gameStarted = true;
          
          if (ysdk && ysdk.features.GameplayAPI) {
            ysdk.features.GameplayAPI.start();
          }
          
          if (soundEnabled) {
            resumeAudioSystem();
          }
          
          restartTimer();
          spawnNext();
        });
      }
    });
  }

  function gameOver(){ 
    clearInterval(timer); 
    current = null; 
    draw(); 
    playSound('gameover');
    stopBackgroundMusic();
    gameStarted = false;
    
    if (ysdk && ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.stop();
    }
    
    if (score > 0) {
      submitScore(score).then(() => {
        bestEl.textContent = best;
      }).catch(err => {
        console.error('Error updating player score:', err);
      });
    }
    
    let modalContent = `<div style="font-size:18px;font-weight:700;margin-bottom:8px">${t('game.gameOver')}</div><div class="small">${t('ui.score')}: ${score}</div><div style="height:10px"></div><div style="display:flex;gap:8px;flex-direction:column">`;
    
    if (!secondChanceUsed) {
      modalContent += `<button class="second-chance-btn" id="secondChance"><img src="ad.png" alt="Ad">${t('game.secondChance')}</button>`;
    }
    
    modalContent += `<div style="display:flex;gap:8px"><button id=again>${t('ui.playAgain')}</button><button id=close class='secondary'>${t('ui.close')}</button></div></div>`;
    
    modal.innerHTML = modalContent;
    overlay.classList.add('show');
    
    document.getElementById('again').onclick = ()=>{ 
      overlay.classList.remove('show'); 
      showAd(() => startGame(), false);
    };
    
    document.getElementById('close').onclick = ()=>{ overlay.classList.remove('show'); }
    
    const secondChanceBtn = document.getElementById('secondChance');
    if (secondChanceBtn) {
      secondChanceBtn.onclick = useSecondChance;
    }
  }

  // Функция для отображения/скрытия меню паузы
  function togglePause(userInitiated = true) {
    paused = !paused;
    userInitiatedPause = userInitiated;
    
    if (paused) {
      lastAdTime = Date.now();
      
      if (ysdk && ysdk.features.GameplayAPI) {
        ysdk.features.GameplayAPI.stop();
      }
      
      if (timer) clearInterval(timer);
      suspendAudioSystem();
      pauseMenuEl.classList.add('show');
    } else {
      pauseMenuEl.classList.remove('show');
      
      if (userInitiatedPause) {
        showAd(() => {
          restartTimer();
          
          if (ysdk && ysdk.features.GameplayAPI) {
            ysdk.features.GameplayAPI.start();
          }
          
          resumeAudioSystem();
        }, false);
      } else {
        restartTimer();
        
        if (ysdk && ysdk.features.GameplayAPI) {
          ysdk.features.GameplayAPI.start();
        }
        
        resumeAudioSystem();
      }
    }
  }

  // input
  document.addEventListener('keydown', e=>{
    if (e.repeat) return;
    if (e.key === 'ArrowLeft'){ move(-1,0, true); draw(); e.preventDefault(); }
    else if (e.key === 'ArrowRight'){ move(1,0, true); draw(); e.preventDefault(); }
    else if (e.key === 'ArrowDown'){ move(0,1, true); draw(); e.preventDefault(); }
    else if (e.key === 'ArrowUp'){ rotate(); draw(); e.preventDefault(); }
    else if (e.code === 'Space'){ hardDrop(); e.preventDefault(); }
    else if (e.key.toLowerCase() === 'p' || e.key === 'Escape'){
      if (!leaderboardPaused) {
        togglePause(true);
      }
      e.preventDefault();
    }
  });

  // safe UI buttons
  (function(){ 
    const restartBtn = document.getElementById('restart'); 
    if (restartBtn) restartBtn.addEventListener('click', ()=>{ 
      showAd(() => startGame(), false);
    }); 
  })();

  // Start button
  startButtonEl.addEventListener('click', () => {
    startScreenEl.style.display = 'none';
    startGame();
  });

  // Pause button
  pauseToggleEl.addEventListener('click', () => {
    togglePause(true);
  });

  // Pause menu buttons
  resumeButtonEl.addEventListener('click', ()=> {
    paused = false;
    pauseMenuEl.classList.remove('show');
    
    if (userInitiatedPause) {
      showAd(() => {
        restartTimer();
        
        if (ysdk && ysdk.features.GameplayAPI) {
          ysdk.features.GameplayAPI.start();
        }
        
        resumeAudioSystem();
      }, false);
    } else {
      restartTimer();
      
      if (ysdk && ysdk.features.GameplayAPI) {
        ysdk.features.GameplayAPI.start();
      }
      
      resumeAudioSystem();
    }
  });

  restartButtonEl.addEventListener('click', () => {
    pauseMenuEl.classList.remove('show');
    showAd(() => startGame(), false);
  });

  soundButtonEl.addEventListener('click', () => {
    toggleSound();
  });

  // Leaderboard button in side panel
  document.getElementById('leaderboard').addEventListener('click', () => {
    leaderboardPaused = true;
    
    if (ysdk && ysdk.features.GameplayAPI) {
      ysdk.features.GameplayAPI.stop();
    }
    
    if (timer) clearInterval(timer);
    suspendAudioSystem();
    
    loadLeaderboard();
    leaderboardOverlayEl.classList.add('show');
  });

  // ИСПРАВЛЕНО: Функция закрытия таблицы лидеров
  leaderboardCloseEl.addEventListener('click', () => {
    leaderboardOverlayEl.classList.remove('show');
    
    // Восстанавливаем состояние игры после закрытия таблицы лидеров
    leaderboardPaused = false;
    
    // Восстанавливаем игру без рекламы
    if (gameStarted && !paused) {
      if (ysdk && ysdk.features.GameplayAPI) {
        ysdk.features.GameplayAPI.start();
      }
      
      restartTimer();
      resumeAudioSystem();
    } else if (gameStarted && paused) {
      // Если игра была на паузе, просто восстанавливаем состояние
      if (ysdk && ysdk.features.GameplayAPI) {
        ysdk.features.GameplayAPI.start();
      }
      
      resumeAudioSystem();
    }
  });

  // Отслеживание видимости страницы - исправлено
  document.addEventListener('visibilitychange', () => {
    pageVisible = !document.hidden;
    
    if (!pageVisible) {
      // При уходе со страницы всегда приостанавливаем звук
      suspendAudioSystem();
      
      // Если игра активна, ставим на паузу
      if (gameStarted && !paused && !leaderboardPaused) {
        togglePause(false);
      }
    } else {
      // При возврате на страницу
      if (gameStarted && paused && !userInitiatedPause && !leaderboardPaused) {
        // Если игра на паузе из-за скрытия страницы, возобновляем
        togglePause(false);
      } else if (gameStarted && !paused && !leaderboardPaused) {
        // Если игра активна, восстанавливаем звук
        resumeAudioSystem();
      }
    }
  });
  
  // Дополнительный обработчик для переключения вкладок (pagehide/pageshow)
  window.addEventListener('pagehide', () => {
    // При скрытии страницы (включая переключение вкладок) всегда выключаем звук
    suspendAudioSystem();
  });
  
  window.addEventListener('pageshow', () => {
    // При показе страницы восстанавливаем звук, если игра активна
    if (gameStarted && !paused && !leaderboardPaused) {
      resumeAudioSystem();
    }
  });

  // Initialize Yandex SDK
  initYandexSDK().then(() => {
    console.log('Yandex SDK initialized successfully');
    
    ysdk.on('game_api_pause', () => {
      if (!paused && gameStarted && !leaderboardPaused) {
        togglePause(false);
      }
    });
    
    ysdk.on('game_api_resume', () => {
      if (paused && gameStarted && !leaderboardPaused && !userInitiatedPause) {
        togglePause(false);
      }
    });
    
    setInterval(() => {
      if (gameStarted && !paused && !leaderboardPaused && pageVisible) {
        showAd(() => {}, true);
      }
    }, AD_INTERVAL);
  }).catch(err => {
    console.error('Failed to initialize Yandex SDK:', err);
    startScreenEl.style.display = 'flex';
    
    currentLanguage = getCurrentLanguage();
    updateTranslations();
  });
  
  // initialization
  resetGrid(); 
  createBoard(); 
  nextPiece = makePiece(); 
  drawNext(); 
})();
</script>
</body>
</html>